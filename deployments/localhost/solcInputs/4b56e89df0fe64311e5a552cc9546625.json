{
  "language": "Solidity",
  "sources": {
    "contracts/test/RequiemWeightedPairFactory_flat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// File: contracts/interfaces/IUniswapV2Callee.sol\n\npragma solidity >=0.5.16;\n\ninterface IUniswapV2Callee {\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n\n// File: contracts/interfaces/ERC20/IERC20.sol\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: contracts/libraries/UQ112x112.sol\n\npragma solidity >=0.8.11;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n  uint224 private constant Q112 = 2**112;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 y) internal pure returns (uint224 z) {\n    z = uint224(y) * Q112; // never overflows\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n    z = x / uint224(y);\n  }\n}\n\n// File: contracts/libraries/TransferHelper.sol\n\npragma solidity >=0.8.11;\n\n// solhint-disable avoid-low-level-calls, reason-string\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n  function safeApprove(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x095ea7b3, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: APPROVE_FAILED\"\n    );\n  }\n\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0xa9059cbb, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FAILED\"\n    );\n  }\n\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FROM_FAILED\"\n    );\n  }\n\n  function safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n  }\n}\n\n// File: contracts/libraries/Math.sol\n\npragma solidity >=0.8.11;\n\n// a library for performing various math operations\n\nlibrary Math {\n  function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    z = x < y ? x : y;\n  }\n\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n  function sqrt(uint256 y) internal pure returns (uint256 z) {\n    if (y > 3) {\n      z = y;\n      uint256 x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n  }\n}\n\n// File: contracts/interfaces/IRequiemFormula.sol\n\npragma solidity >=0.8.11;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n  function getReserveAndWeights(address pair, address tokenA)\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getFactoryReserveAndWeights(\n    address factory,\n    address pair,\n    address tokenA\n  )\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountIn);\n\n  function getPairAmountIn(\n    address pair,\n    address tokenIn,\n    uint256 amountOut\n  ) external view returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountOut);\n\n  function getPairAmountOut(\n    address pair,\n    address tokenIn,\n    uint256 amountIn\n  ) external view returns (uint256 amountOut);\n\n  function getAmountsIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsIn(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getAmountsOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsOut(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function ensureConstantValue(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 balance0Adjusted,\n    uint256 balance1Adjusted,\n    uint32 tokenWeight0\n  ) external view returns (bool);\n\n  function getReserves(\n    address pair,\n    address tokenA,\n    address tokenB\n  ) external view returns (uint256 reserveA, uint256 reserveB);\n\n  function getOtherToken(address pair, address tokenA)\n    external\n    view\n    returns (address tokenB);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function sortTokens(address tokenA, address tokenB)\n    external\n    pure\n    returns (address token0, address token1);\n\n  function mintLiquidityFee(\n    uint256 totalLiquidity,\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 tokenWeight0,\n    uint32 tokenWeight1,\n    uint112 collectedFee0,\n    uint112 collectedFee1\n  ) external view returns (uint256 amount);\n}\n\n// File: contracts/interfaces/IRequiemSwap.sol\n\npragma solidity ^0.8.11;\n\ninterface IRequiemSwap {\n  // this funtion requires the correctly calculated amounts as input\n  // the others are supposed to implement that calculation\n  // no return value required since the amounts are already known\n  function onSwap(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOut,\n    address to\n  ) external;\n\n  //\n  function onSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to\n  ) external returns (uint256);\n\n  function onSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address to\n  ) external returns (uint256);\n\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n}\n\n// File: contracts/interfaces/IRequiemPairERC20.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPairERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\n// File: contracts/RequiemPairERC20.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable not-rely-on-time, no-inline-assembly, var-name-mixedcase, max-line-length\n\ncontract RequiemPairERC20 is IRequiemPairERC20 {\n  string public constant name = \"Requiem Pair Liquidity Provider\";\n  string public constant symbol = \"RPLP\";\n  uint8 public constant decimals = 18;\n  uint256 public totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  bytes32 public override DOMAIN_SEPARATOR;\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant override PERMIT_TYPEHASH =\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n  mapping(address => uint256) public nonces;\n\n  constructor() {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(name)),\n        keccak256(bytes(\"1\")),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  function _mint(address to, uint256 value) internal {\n    totalSupply += value;\n    balanceOf[to] += value;\n    emit Transfer(address(0), to, value);\n  }\n\n  function _burn(address from, uint256 value) internal {\n    balanceOf[from] -= value;\n    totalSupply -= value;\n    emit Transfer(from, address(0), value);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  ) private {\n    allowance[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  ) private {\n    balanceOf[from] -= value;\n    balanceOf[to] += value;\n    emit Transfer(from, to, value);\n  }\n\n  function approve(address spender, uint256 value) external returns (bool) {\n    _approve(msg.sender, spender, value);\n    return true;\n  }\n\n  function transfer(address to, uint256 value) external returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool) {\n    if (allowance[from][msg.sender] != type(uint256).max) {\n      allowance[from][msg.sender] -= value;\n    }\n    _transfer(from, to, value);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(deadline >= block.timestamp, \"RLP: EXPIRED\");\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            nonces[owner]++,\n            deadline\n          )\n        )\n      )\n    );\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(\n      recoveredAddress != address(0) && recoveredAddress == owner,\n      \"RLP: IS\"\n    );\n    _approve(owner, spender, value);\n  }\n}\n\n// File: contracts/interfaces/IRequiemWeightedPair.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemWeightedPair is IRequiemPairERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n\n// File: contracts/libraries/helpers/RequiemErrors.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.11;\n\n// solhint-disable\nlibrary RequiemErrors {\n  /**\n   * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n   * supported.\n   */\n  function _require(bool condition, uint256 errorCode) internal pure {\n    if (!condition) RequiemErrors._revert(errorCode);\n  }\n\n  /**\n   * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n   */\n  function _revert(uint256 errorCode) internal pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'REQ#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n      // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n      // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n      // the '0' character.\n\n      let units := add(mod(errorCode, 10), 0x30)\n\n      errorCode := div(errorCode, 10)\n      let tenths := add(mod(errorCode, 10), 0x30)\n\n      errorCode := div(errorCode, 10)\n      let hundreds := add(mod(errorCode, 10), 0x30)\n\n      // With the individual characters, we can now construct the full string. The \"REQ#\" part is a known constant\n      // (0x52455123): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n      // characters to it, each shifted by a multiple of 8.\n      // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n      // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n      // array).\n\n      let revertReason := shl(\n        200,\n        add(\n          0x52455123000000,\n          add(add(units, shl(8, tenths)), shl(16, hundreds))\n        )\n      )\n\n      // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n      // message will have the following layout:\n      // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n      // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n      // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n      mstore(\n        0x0,\n        0x08c379a000000000000000000000000000000000000000000000000000000000\n      )\n      // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n      mstore(\n        0x04,\n        0x0000000000000000000000000000000000000000000000000000000000000020\n      )\n      // The string length is fixed: 7 characters.\n      mstore(0x24, 7)\n      // Finally, the string itself is stored.\n      mstore(0x44, revertReason)\n\n      // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n      // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n      revert(0, 100)\n    }\n  }\n}\n\nlibrary Errors {\n  // Math\n  uint256 internal constant ADD_OVERFLOW = 0;\n  uint256 internal constant SUB_OVERFLOW = 1;\n  uint256 internal constant SUB_UNDERFLOW = 2;\n  uint256 internal constant MUL_OVERFLOW = 3;\n  uint256 internal constant ZERO_DIVISION = 4;\n  uint256 internal constant DIV_INTERNAL = 5;\n  uint256 internal constant X_OUT_OF_BOUNDS = 6;\n  uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n  uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n  uint256 internal constant INVALID_EXPONENT = 9;\n\n  // Input\n  uint256 internal constant OUT_OF_BOUNDS = 100;\n  uint256 internal constant UNSORTED_ARRAY = 101;\n  uint256 internal constant UNSORTED_TOKENS = 102;\n  uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n  uint256 internal constant ZERO_TOKEN = 104;\n\n  // Shared pools\n  uint256 internal constant MIN_TOKENS = 200;\n  uint256 internal constant MAX_TOKENS = 201;\n  uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n  uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n  uint256 internal constant MINIMUM_BPT = 204;\n  uint256 internal constant CALLER_NOT_VAULT = 205;\n  uint256 internal constant UNINITIALIZED = 206;\n  uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n  uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n  uint256 internal constant EXPIRED_PERMIT = 209;\n  uint256 internal constant NOT_TWO_TOKENS = 210;\n\n  // Pools\n  uint256 internal constant MIN_AMP = 300;\n  uint256 internal constant MAX_AMP = 301;\n  uint256 internal constant MIN_WEIGHT = 302;\n  uint256 internal constant MAX_STABLE_TOKENS = 303;\n  uint256 internal constant MAX_IN_RATIO = 304;\n  uint256 internal constant MAX_OUT_RATIO = 305;\n  uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n  uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n  uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n  uint256 internal constant INVALID_TOKEN = 309;\n  uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n  uint256 internal constant ZERO_INVARIANT = 311;\n  uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n  uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n  uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n  uint256 internal constant ORACLE_INVALID_INDEX = 315;\n  uint256 internal constant ORACLE_BAD_SECS = 316;\n  uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n  uint256 internal constant AMP_ONGOING_UPDATE = 318;\n  uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n  uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n  uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n  uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n  uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n  uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n  uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n  uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n  uint256 internal constant SWAPS_DISABLED = 327;\n  uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n  uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n  uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n  uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n  uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n  uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n  uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n  uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n  uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n  uint256 internal constant UNAUTHORIZED_EXIT = 337;\n  uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n  uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n  uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n  uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n  uint256 internal constant INVALID_INITIALIZATION = 342;\n\n  // Lib\n  uint256 internal constant REENTRANCY = 400;\n  uint256 internal constant SENDER_NOT_ALLOWED = 401;\n  uint256 internal constant PAUSED = 402;\n  uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n  uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n  uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n  uint256 internal constant INSUFFICIENT_BALANCE = 406;\n  uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n  uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n  uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n  uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n  uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n  uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n  uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n  uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n  uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n  uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n  uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n  uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n  uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n  uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n  uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n  uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n  uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n  uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n  uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n  uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n  uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n  uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n  uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n  uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n  uint256 internal constant NOT_PAUSED = 431;\n\n  // Vault\n  uint256 internal constant INVALID_POOL_ID = 500;\n  uint256 internal constant CALLER_NOT_POOL = 501;\n  uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n  uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n  uint256 internal constant INVALID_SIGNATURE = 504;\n  uint256 internal constant EXIT_BELOW_MIN = 505;\n  uint256 internal constant JOIN_ABOVE_MAX = 506;\n  uint256 internal constant SWAP_LIMIT = 507;\n  uint256 internal constant SWAP_DEADLINE = 508;\n  uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n  uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n  uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n  uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n  uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n  uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n  uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n  uint256 internal constant INSUFFICIENT_ETH = 516;\n  uint256 internal constant UNALLOCATED_ETH = 517;\n  uint256 internal constant ETH_TRANSFER = 518;\n  uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n  uint256 internal constant TOKENS_MISMATCH = 520;\n  uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n  uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n  uint256 internal constant TOKENS_ALREADY_SET = 523;\n  uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n  uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n  uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n  uint256 internal constant POOL_NO_TOKENS = 527;\n  uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n  // Fees\n  uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n  uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n  uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n\n// File: contracts/libraries/EnumerableSet.sol\n\n// Based on the EnumerableSet library from OpenZeppelin Contracts, altered to remove the base private functions that\n// work on bytes32, replacing them with a native implementation for address and bytes32 values, to reduce bytecode\n// size and runtime costs.\n// The `unchecked_at` function was also added, which allows for more gas efficient data reads in some scenarios.\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n  // The original OpenZeppelin implementation uses a generic Set type with bytes32 values: this was replaced with\n  // AddressSet, which uses address keys natively, resulting in more dense bytecode.\n\n  struct AddressSet {\n    // Storage of set values\n    address[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(address => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    if (!contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value)\n    internal\n    returns (bool)\n  {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      // The swap is only necessary if we're not removing the last element\n      if (toDeleteIndex != lastIndex) {\n        address lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value)\n    internal\n    view\n    returns (bool)\n  {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    RequiemErrors._require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n    return unchecked_at(set, index);\n  }\n\n  /**\n   * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\n   * than {length}). O(1).\n   *\n   * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n   * within bounds.\n   */\n  function unchecked_at(AddressSet storage set, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    return set._values[index];\n  }\n\n  function rawIndexOf(AddressSet storage set, address value)\n    internal\n    view\n    returns (uint256)\n  {\n    return set._indexes[value] - 1;\n  }\n\n  struct Bytes32Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    if (!contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value)\n    internal\n    returns (bool)\n  {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      // The swap is only necessary if we're not removing the last element\n      if (toDeleteIndex != lastIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value)\n    internal\n    view\n    returns (bool)\n  {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index)\n    internal\n    view\n    returns (bytes32)\n  {\n    RequiemErrors._require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n    return unchecked_at(set, index);\n  }\n\n  /**\n   * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\n   * than {length}). O(1).\n   *\n   * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n   * within bounds.\n   */\n  function unchecked_at(Bytes32Set storage set, uint256 index)\n    internal\n    view\n    returns (bytes32)\n  {\n    return set._values[index];\n  }\n\n  function rawIndexOf(Bytes32Set storage set, bytes32 value)\n    internal\n    view\n    returns (uint256)\n  {\n    return set._indexes[value] - 1;\n  }\n}\n\n// File: contracts/interfaces/IRequiemWeightedPairFactory.sol\n\npragma solidity >=0.8.11;\n\ninterface IRequiemWeightedPairFactory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint32 tokenWeight0,\n    uint32 swapFee,\n    uint256\n  );\n\n  function feeTo() external view returns (address);\n\n  function formula() external view returns (address);\n\n  function protocolFee() external view returns (uint256);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function isPair(address) external view returns (bool);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external returns (address pair);\n\n  function getWeightsAndSwapFee(address pair)\n    external\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    );\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  function setProtocolFee(uint256) external;\n}\n\n// File: contracts/RequiemWeightedPair.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string, avoid-low-level-calls\n\ncontract RequiemWeightedPair is\n  IRequiemSwap,\n  IRequiemWeightedPair,\n  RequiemPairERC20\n{\n  using UQ112x112 for uint224;\n\n  uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n  bytes4 private constant SELECTOR =\n    bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n  address public factory;\n  address public token0;\n  address public token1;\n\n  uint112 private reserve0; // uses single storage slot, accessible via getReserves\n  uint112 private reserve1; // uses single storage slot, accessible via getReserves\n  uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n  uint256 public price0CumulativeLast;\n  uint256 public price1CumulativeLast;\n  uint256 private unlocked = 1;\n  address public formula;\n\n  uint112 private collectedFee0; // uses single storage slot, accessible via getReserves\n  uint112 private collectedFee1; // uses single storage slot, accessible via getReserves\n\n  uint32 private tokenWeight0;\n  uint32 private tokenWeight1;\n  uint32 private swapFee;\n\n  modifier lock() {\n    require(unlocked == 1, \"REQLP: L\");\n    unlocked = 0;\n    _;\n    unlocked = 1;\n  }\n\n  function getReserves()\n    public\n    view\n    returns (\n      uint112 _reserve0,\n      uint112 _reserve1,\n      uint32 _blockTimestampLast\n    )\n  {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n  }\n\n  function getCollectedFees()\n    public\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1)\n  {\n    _collectedFee0 = collectedFee0;\n    _collectedFee1 = collectedFee1;\n  }\n\n  function getTokenWeights()\n    public\n    view\n    returns (uint32 _tokenWeight0, uint32 _tokenWeight1)\n  {\n    _tokenWeight0 = tokenWeight0;\n    _tokenWeight1 = tokenWeight1;\n  }\n\n  function getSwapFee() public view returns (uint32 _swapFee) {\n    _swapFee = swapFee;\n  }\n\n  function _safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) private {\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(SELECTOR, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"REQLP: TF\"\n    );\n  }\n\n  constructor() {\n    factory = msg.sender;\n  }\n\n  // called once by the factory at time of deployment\n  function initialize(\n    address _token0,\n    address _token1,\n    uint32 _tokenWeight0,\n    uint32 _swapFee\n  ) external {\n    require(msg.sender == factory, \"REQLP: F\");\n    // sufficient check\n    token0 = _token0;\n    token1 = _token1;\n    tokenWeight0 = _tokenWeight0;\n    tokenWeight1 = 100 - tokenWeight0;\n    swapFee = _swapFee;\n    formula = IRequiemWeightedPairFactory(factory).formula();\n  }\n\n  // update reserves and, on the first call per block, price accumulators\n  function _update(\n    uint256 balance0,\n    uint256 balance1,\n    uint112 _reserve0,\n    uint112 _reserve1\n  ) private {\n    uint32 _tokenWeight0 = tokenWeight0;\n    require(\n      balance0 * (100 - _tokenWeight0) <= type(uint112).max &&\n        balance1 * _tokenWeight0 <= type(uint112).max,\n      \"REQLP: O\"\n    );\n    uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n    // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n      // * never overflows, and + overflow is desired\n      uint112 mReserve0 = _reserve0 * (100 - _tokenWeight0);\n      uint112 mReserve1 = _reserve1 * _tokenWeight0;\n      price0CumulativeLast +=\n        uint256(UQ112x112.encode(mReserve1).uqdiv(mReserve0)) *\n        timeElapsed;\n      price1CumulativeLast +=\n        uint256(UQ112x112.encode(mReserve0).uqdiv(mReserve1)) *\n        timeElapsed;\n    }\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n  }\n\n  function _mintFee(uint112 _reserve0, uint112 _reserve1)\n    private\n    returns (bool feeOn)\n  {\n    address feeTo = IRequiemWeightedPairFactory(factory).feeTo();\n    uint112 protocolFee = uint112(\n      IRequiemWeightedPairFactory(factory).protocolFee()\n    );\n    feeOn = feeTo != address(0);\n    (uint112 _collectedFee0, uint112 _collectedFee1) = getCollectedFees();\n    if (\n      protocolFee > 0 && feeOn && (_collectedFee0 > 0 || _collectedFee1 > 0)\n    ) {\n      uint32 _tokenWeight0 = tokenWeight0;\n      uint256 liquidity = IRequiemFormula(formula).mintLiquidityFee(\n        totalSupply,\n        _reserve0,\n        _reserve1,\n        _tokenWeight0,\n        100 - _tokenWeight0,\n        _collectedFee0 / protocolFee,\n        _collectedFee1 / protocolFee\n      );\n      if (liquidity > 0) _mint(feeTo, liquidity);\n    }\n    if (_collectedFee0 > 0) collectedFee0 = 0;\n    if (_collectedFee1 > 0) collectedFee1 = 0;\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function mint(address to) external lock returns (uint256 liquidity) {\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    uint256 balance0 = IERC20(token0).balanceOf(address(this));\n    uint256 balance1 = IERC20(token1).balanceOf(address(this));\n    uint256 amount0 = balance0 - _reserve0;\n    uint256 amount1 = balance1 - _reserve1;\n    _mintFee(_reserve0, _reserve1);\n    uint256 _totalSupply = totalSupply;\n    // gas savings, must be defined here since totalSupply can update in _mintFee\n    if (_totalSupply == 0) {\n      liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n      _mint(address(0), MINIMUM_LIQUIDITY);\n      // permanently lock the first MINIMUM_LIQUIDITY tokens\n    } else {\n      liquidity = Math.min(\n        (amount0 * _totalSupply) / _reserve0,\n        (amount1 * _totalSupply) / _reserve1\n      );\n    }\n    require(liquidity > 0, \"REQLP: ILM\");\n    _mint(to, liquidity);\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Mint(msg.sender, amount0, amount1);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function burn(address to)\n    external\n    lock\n    returns (uint256 amount0, uint256 amount1)\n  {\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n    uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n    uint256 liquidity = balanceOf[address(this)];\n    _mintFee(_reserve0, _reserve1);\n    uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n    amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n    amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n    require(amount0 > 0 && amount1 > 0, \"REQLP: ILB\");\n    _burn(address(this), liquidity);\n    _safeTransfer(_token0, to, amount0);\n    _safeTransfer(_token1, to, amount1);\n    balance0 = IERC20(_token0).balanceOf(address(this));\n    balance1 = IERC20(_token1).balanceOf(address(this));\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Burn(msg.sender, amount0, amount1, to);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata\n  ) external lock {\n    _swap(amount0Out, amount1Out, to);\n  }\n\n  //\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address,\n    uint256 amountIn\n  ) external view returns (uint256) {\n    (\n      uint256 reserveIn,\n      uint256 reserveOut,\n      uint32 tokenWeightIn,\n      uint32 tokenWeightOut\n    ) = tokenIn == token0\n        ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n        : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n    return\n      IRequiemFormula(formula).getAmountOut(\n        amountIn,\n        reserveIn,\n        reserveOut,\n        tokenWeightIn,\n        tokenWeightOut,\n        swapFee\n      );\n  }\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address,\n    uint256 amountOut\n  ) external view returns (uint256) {\n    (\n      uint256 reserveIn,\n      uint256 reserveOut,\n      uint32 tokenWeightIn,\n      uint32 tokenWeightOut\n    ) = tokenIn == token0\n        ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n        : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n    return\n      IRequiemFormula(formula).getAmountIn(\n        amountOut,\n        reserveIn,\n        reserveOut,\n        tokenWeightIn,\n        tokenWeightOut,\n        swapFee\n      );\n  }\n\n  // force balances to match reserves\n  function skim(address to) external lock {\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    _safeTransfer(\n      _token0,\n      to,\n      IERC20(_token0).balanceOf(address(this)) - reserve0\n    );\n    _safeTransfer(\n      _token1,\n      to,\n      IERC20(_token1).balanceOf(address(this)) - reserve1\n    );\n  }\n\n  // force reserves to match balances\n  function sync() external lock {\n    _update(\n      IERC20(token0).balanceOf(address(this)),\n      IERC20(token1).balanceOf(address(this)),\n      reserve0,\n      reserve1\n    );\n  }\n\n  // calculates output amount for given input and executes the respective trade\n  // viable for use in multi swaps as it returns the output value\n  // requires the amount in to be sent to this address beforehand\n  function onSwapGivenIn(\n    address tokenIn,\n    address,\n    uint256 amountIn,\n    uint256,\n    address to\n  ) external override lock returns (uint256) {\n    bool inToken0 = tokenIn == token0;\n    (\n      uint256 reserveIn,\n      uint256 reserveOut,\n      uint32 tokenWeightIn,\n      uint32 tokenWeightOut\n    ) = inToken0\n        ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n        : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n    uint256 amountOut = IRequiemFormula(formula).getAmountOut(\n      amountIn,\n      reserveIn,\n      reserveOut,\n      tokenWeightIn,\n      tokenWeightOut,\n      swapFee\n    );\n    (uint256 amount0Out, uint256 amount1Out) = inToken0\n      ? (uint256(0), amountOut)\n      : (amountOut, uint256(0));\n    return _swap(amount0Out, amount1Out, to);\n  }\n\n  // calculates input amount for given output and executes the respective trade\n  // calling this one only makes sense if a single trade is supposd to be executed in the tx\n  // requires the amount in to be sent to this address beforehand\n  function onSwapGivenOut(\n    address tokenIn,\n    address,\n    uint256 amountOut,\n    uint256,\n    address to\n  ) external override lock returns (uint256) {\n    bool inToken0 = tokenIn == token0;\n    (\n      uint256 reserveIn,\n      uint256 reserveOut,\n      uint32 tokenWeightIn,\n      uint32 tokenWeightOut\n    ) = tokenIn == token0\n        ? (reserve0, reserve1, tokenWeight0, tokenWeight1)\n        : (reserve1, reserve0, tokenWeight1, tokenWeight0);\n    uint256 amountIn = IRequiemFormula(formula).getAmountIn(\n      amountOut,\n      reserveIn,\n      reserveOut,\n      tokenWeightIn,\n      tokenWeightOut,\n      swapFee\n    );\n    (uint256 amount0Out, uint256 amount1Out) = inToken0\n      ? (uint256(0), amountIn)\n      : (amountIn, uint256(0));\n    return _swap(amount0Out, amount1Out, to);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function _swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to\n  ) internal returns (uint256) {\n    require(amount0Out > 0 || amount1Out > 0, \"REQLP: IOA\");\n    uint112 _reserve0 = reserve0; // gas savings\n    uint112 _reserve1 = reserve1; // gas savings\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: IL\");\n\n    uint256 balance0;\n    uint256 balance1;\n    {\n      // scope for _token{0,1}, avoids stack too deep errors\n      address _token0 = token0;\n      address _token1 = token1;\n      require(to != _token0 && to != _token1, \"REQLP: IT\");\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n      balance0 = IERC20(_token0).balanceOf(address(this));\n      balance1 = IERC20(_token1).balanceOf(address(this));\n    }\n    uint256 amount0In = balance0 > _reserve0 - amount0Out\n      ? balance0 - (_reserve0 - amount0Out)\n      : 0;\n    uint256 amount1In = balance1 > _reserve1 - amount1Out\n      ? balance1 - (_reserve1 - amount1Out)\n      : 0;\n\n    require(amount0In > 0 || amount1In > 0, \"REQLP: IIA\");\n    {\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint256 balance0Adjusted = balance0 * 10000;\n      uint256 balance1Adjusted = balance1 * 10000;\n      {\n        // avoids stack too deep errors\n        if (amount0In > 0) {\n          uint256 amount0InFee = amount0In * swapFee;\n          balance0Adjusted -= amount0InFee;\n          collectedFee0 = uint112(uint256(collectedFee0) + amount0InFee);\n        }\n        if (amount1In > 0) {\n          uint256 amount1InFee = amount1In * swapFee;\n          balance1Adjusted -= amount1InFee;\n          collectedFee1 = uint112(uint256(collectedFee1) + amount1InFee);\n        }\n        uint32 _tokenWeight0 = tokenWeight0; // gas savings\n        if (_tokenWeight0 == 50) {\n          // gas savings for pair 50/50\n          require(\n            balance0Adjusted * balance1Adjusted >=\n              uint256(_reserve0) * _reserve1 * (10000**2),\n            \"REQLP: K\"\n          );\n        } else {\n          require(\n            IRequiemFormula(formula).ensureConstantValue(\n              uint256(_reserve0) * 10000,\n              uint256(_reserve1) * 10000,\n              balance0Adjusted,\n              balance1Adjusted,\n              _tokenWeight0\n            ),\n            \"REQLP: K\"\n          );\n        }\n      }\n    }\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    return amount0Out > 0 ? amount0Out : amount1Out;\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function onSwap(\n    address tokenIn,\n    address,\n    uint256,\n    uint256 amountOut,\n    address to\n  ) external override lock {\n    (uint256 amount0Out, uint256 amount1Out) = token0 == tokenIn\n      ? (uint256(0), amountOut)\n      : (amountOut, uint256(0));\n    require(amount0Out > 0 || amount1Out > 0, \"REQLP: IOA\");\n    uint112 _reserve0 = reserve0; // gas savings\n    uint112 _reserve1 = reserve1; // gas savings\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, \"REQLP: IL\");\n\n    uint256 balance0;\n    uint256 balance1;\n    {\n      // scope for _token{0,1}, avoids stack too deep errors\n      address _token0 = token0;\n      address _token1 = token1;\n      require(to != _token0 && to != _token1, \"REQLP: IT\");\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n      balance0 = IERC20(_token0).balanceOf(address(this));\n      balance1 = IERC20(_token1).balanceOf(address(this));\n    }\n    uint256 amount0In = balance0 > _reserve0 - amount0Out\n      ? balance0 - (_reserve0 - amount0Out)\n      : 0;\n    uint256 amount1In = balance1 > _reserve1 - amount1Out\n      ? balance1 - (_reserve1 - amount1Out)\n      : 0;\n\n    require(amount0In > 0 || amount1In > 0, \"REQLP: IIA\");\n    {\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint256 balance0Adjusted = balance0 * 10000;\n      uint256 balance1Adjusted = balance1 * 10000;\n      {\n        // avoids stack too deep errors\n        if (amount0In > 0) {\n          uint256 amount0InFee = amount0In * swapFee;\n          balance0Adjusted -= amount0InFee;\n          collectedFee0 = uint112(uint256(collectedFee0) + amount0InFee);\n        }\n        if (amount1In > 0) {\n          uint256 amount1InFee = amount1In * swapFee;\n          balance1Adjusted -= amount1InFee;\n          collectedFee1 = uint112(uint256(collectedFee1) + amount1InFee);\n        }\n        uint32 _tokenWeight0 = tokenWeight0; // gas savings\n        if (_tokenWeight0 == 50) {\n          // gas savings for pair 50/50\n          require(\n            balance0Adjusted * balance1Adjusted >=\n              uint256(_reserve0) * _reserve1 * (10000**2),\n            \"REQLP: K\"\n          );\n        } else {\n          require(\n            IRequiemFormula(formula).ensureConstantValue(\n              uint256(_reserve0) * 10000,\n              uint256(_reserve1) * 10000,\n              balance0Adjusted,\n              balance1Adjusted,\n              _tokenWeight0\n            ),\n            \"REQLP: K\"\n          );\n        }\n      }\n    }\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n  }\n}\n\n// File: contracts/RequiemWeightedPairFactory.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable no-inline-assembly\n\ncontract RequiemWeightedPairFactory is IRequiemWeightedPairFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  address public feeTo;\n  address public formula;\n  uint256 public protocolFee;\n  address public feeToSetter;\n  bytes32 public constant INIT_CODE_HASH =\n    keccak256(abi.encodePacked(type(RequiemWeightedPair).creationCode));\n\n  mapping(bytes32 => address) private _pairSalts;\n  address[] public allPairs;\n  mapping(address => uint64) private _pairs;\n\n  mapping(IERC20 => mapping(IERC20 => EnumerableSet.AddressSet))\n    internal tokenPairs;\n\n  constructor(address _feeToSetter, address _formula) {\n    feeToSetter = _feeToSetter;\n    formula = _formula;\n  }\n\n  function isPair(address b) external view returns (bool) {\n    return _pairs[b] > 0;\n  }\n\n  function allPairsLength() external view returns (uint256) {\n    return allPairs.length;\n  }\n\n  function getPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external view returns (address pair) {\n    (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB\n      ? (tokenA, tokenB, tokenWeightA)\n      : (tokenB, tokenA, 100 - tokenWeightA);\n    bytes32 salt = keccak256(\n      abi.encodePacked(token0, token1, tokenWeight0, swapFee)\n    );\n    pair = _pairSalts[salt];\n  }\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external returns (address pair) {\n    require(tokenA != tokenB, \"RLP: IA\");\n    require(\n      tokenWeightA >= 2 && tokenWeightA <= 98 && (tokenWeightA % 2) == 0,\n      \"RLP: IW\"\n    );\n    // swap fee from [0.01% - 20%]\n    require(swapFee >= 1 && swapFee <= 2000, \"RLP: ISF\");\n    (address token0, address token1, uint32 tokenWeight0) = tokenA < tokenB\n      ? (tokenA, tokenB, tokenWeightA)\n      : (tokenB, tokenA, 100 - tokenWeightA);\n    require(token0 != address(0), \"RLP: ZA\");\n    // single check is sufficient\n    bytes memory bytecode = type(RequiemWeightedPair).creationCode;\n    bytes32 salt = keccak256(\n      abi.encodePacked(token0, token1, tokenWeight0, swapFee)\n    );\n    require(_pairSalts[salt] == address(0), \"RLP: PE\");\n    assembly {\n      pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n    }\n    IRequiemWeightedPair(pair).initialize(\n      token0,\n      token1,\n      tokenWeight0,\n      swapFee\n    );\n\n    tokenPairs[IERC20(token0)][IERC20(token1)].add(pair);\n    tokenPairs[IERC20(token1)][IERC20(token0)].add(pair);\n\n    _pairSalts[salt] = address(pair);\n    allPairs.push(pair);\n    uint64 weightAndFee = uint64(swapFee);\n    weightAndFee |= uint64(tokenWeight0) << 32;\n    _pairs[address(pair)] = weightAndFee;\n    emit PairCreated(\n      token0,\n      token1,\n      pair,\n      tokenWeight0,\n      swapFee,\n      allPairs.length\n    );\n  }\n\n  function setFeeTo(address _feeTo) external {\n    require(msg.sender == feeToSetter, \"RLP: F\");\n    feeTo = _feeTo;\n  }\n\n  function setFeeToSetter(address _feeToSetter) external {\n    require(msg.sender == feeToSetter, \"RLP: F\");\n    feeToSetter = _feeToSetter;\n  }\n\n  function setProtocolFee(uint256 _protocolFee) external {\n    require(msg.sender == feeToSetter, \"RLP: F\");\n    require(\n      _protocolFee == 0 || (_protocolFee >= 10000 && _protocolFee <= 100000),\n      \"RLP: IPF\"\n    );\n    protocolFee = _protocolFee;\n  }\n\n  function getWeightsAndSwapFee(address pair)\n    public\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    )\n  {\n    uint64 weightAndFee = _pairs[pair];\n    if (weightAndFee > 0) {\n      swapFee = uint32(weightAndFee);\n      tokenWeight0 = uint32(weightAndFee >> 32);\n      tokenWeight1 = 100 - tokenWeight0;\n    } else {\n      // Default is 0.3%\n      return (50, 50, 30);\n    }\n  }\n\n  function getPairs(IERC20 token0, IERC20 token1)\n    external\n    view\n    returns (address[] memory _tokenPairs)\n  {\n    uint256 length = tokenPairs[token0][token1].length();\n    _tokenPairs = new address[](length);\n    for (uint256 i = 0; i < length; i++) {\n      _tokenPairs[i] = tokenPairs[token0][token1].at(i);\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}