{
  "language": "Solidity",
  "sources": {
    "contracts/test/RequiemFormula_flat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// File: interfaces/IRequiemFactory.sol\n\npragma solidity >=0.5.16;\n\ninterface IRequiemFactory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint32 tokenWeight0,\n    uint32 swapFee,\n    uint256\n  );\n\n  function feeTo() external view returns (address);\n\n  function formula() external view returns (address);\n\n  function protocolFee() external view returns (uint256);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function isPair(address) external view returns (bool);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external returns (address pair);\n\n  function getWeightsAndSwapFee(address pair)\n    external\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    );\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  function setProtocolFee(uint256) external;\n}\n\n// File: interfaces/IRequiemERC20.sol\n\npragma solidity ^0.8.10;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\n// File: interfaces/IRequiemPair.sol\n\npragma solidity ^0.8.10;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPair is IRequiemERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n\n// File: interfaces/IRequiemFormula.sol\n\npragma solidity >=0.8.10;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n  function getReserveAndWeights(address pair, address tokenA)\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getFactoryReserveAndWeights(\n    address factory,\n    address pair,\n    address tokenA\n  )\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountIn);\n\n  function getPairAmountIn(\n    address pair,\n    address tokenIn,\n    uint256 amountOut\n  ) external view returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountOut);\n\n  function getPairAmountOut(\n    address pair,\n    address tokenIn,\n    uint256 amountIn\n  ) external view returns (uint256 amountOut);\n\n  function getAmountsIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsIn(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getAmountsOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsOut(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function ensureConstantValue(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 balance0Adjusted,\n    uint256 balance1Adjusted,\n    uint32 tokenWeight0\n  ) external view returns (bool);\n\n  function getReserves(\n    address pair,\n    address tokenA,\n    address tokenB\n  ) external view returns (uint256 reserveA, uint256 reserveB);\n\n  function getOtherToken(address pair, address tokenA)\n    external\n    view\n    returns (address tokenB);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function sortTokens(address tokenA, address tokenB)\n    external\n    pure\n    returns (address token0, address token1);\n\n  function mintLiquidityFee(\n    uint256 totalLiquidity,\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 tokenWeight0,\n    uint32 tokenWeight1,\n    uint112 collectedFee0,\n    uint112 collectedFee1\n  ) external view returns (uint256 amount);\n}\n\n// File: RequiemFormula.sol\n\npragma solidity >=0.8.10;\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string, no-unused-vars\n\ncontract RequiemFormula is IRequiemFormula {\n  uint256 private constant ONE = 1;\n  uint8 private constant MIN_PRECISION = 32;\n  uint8 private constant MAX_PRECISION = 127;\n\n  uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n  uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n  uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n  uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n  uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n  uint256 private constant OPT_LOG_MAX_VAL =\n    0x15bf0a8b1457695355fb8ac404e7a79e3;\n  uint256 private constant OPT_EXP_MAX_VAL =\n    0x800000000000000000000000000000000;\n\n  uint256 private constant LAMBERT_CONV_RADIUS =\n    0x002f16ac6c59de6f8d5d6f63c1482a7c86;\n  uint256 private constant LAMBERT_POS2_SAMPLE =\n    0x0003060c183060c183060c183060c18306;\n  uint256 private constant LAMBERT_POS2_MAXVAL =\n    0x01af16ac6c59de6f8d5d6f63c1482a7c80;\n  uint256 private constant LAMBERT_POS3_MAXVAL =\n    0x6b22d43e72c326539cceeef8bb48f255ff;\n\n  uint256 private constant MAX_UNF_WEIGHT =\n    0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\n\n  uint256[128] private maxExpArray;\n\n  function initMaxExpArray() internal {\n    maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n    maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n    maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n    maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n    maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n    maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n    maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n    maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n    maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n    maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n    maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n    maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n    maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n    maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n    maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n    maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n    maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n    maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n    maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n    maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n    maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n    maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n    maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n    maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n    maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n    maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n    maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n    maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n    maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n    maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n    maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n    maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n    maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n    maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n    maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n    maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n    maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n    maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n    maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n    maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n    maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n    maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n    maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n    maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n    maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n    maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n    maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n    maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n    maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n    maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n    maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n    maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n    maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n    maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n    maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n    maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n    maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n    maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n    maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n    maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n    maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n    maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n    maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n    maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n    maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n    maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n    maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n    maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n    maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n    maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n    maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n    maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n    maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n    maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n    maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n    maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n    maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n    maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n    maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n    maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n    maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n    maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n    maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n    maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n    maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n    maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n    maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n    maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n    maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n    maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n    maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n    maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n    maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n    maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n    maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n    maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n  }\n\n  constructor() {\n    initMaxExpArray();\n  }\n\n  /**\n   * @dev General Description:\n   *     Determine a value of precision.\n   *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n   *     Return the result along with the precision used.\n   *\n   * Detailed Description:\n   *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n   *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n   *     The larger \"precision\" is, the more accurately this value represents the real value.\n   *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n   *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n   *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n   *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n   *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n   *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n   *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n   */\n  function power(\n    uint256 _baseN,\n    uint256 _baseD,\n    uint32 _expN,\n    uint32 _expD\n  ) internal view returns (uint256, uint8) {\n    require(_baseN >= _baseD, \"not support _baseN < _baseD\");\n    require(_baseN < MAX_NUM);\n\n    uint256 baseLog;\n    uint256 base = (_baseN * FIXED_1) / _baseD;\n    if (base < OPT_LOG_MAX_VAL) {\n      baseLog = optimalLog(base);\n    } else {\n      baseLog = generalLog(base);\n    }\n\n    uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n    if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n      return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n    } else {\n      uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n      return (\n        generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\n        precision\n      );\n    }\n  }\n  \n  /**\n   * @dev computes log(x / FIXED_1) * FIXED_1.\n   * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n   */\n  function generalLog(uint256 x) internal pure returns (uint256) {\n    uint256 res = 0;\n\n    // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n    if (x >= FIXED_2) {\n      uint8 count = floorLog2(x / FIXED_1);\n      x >>= count;\n      // now x < 2\n      res = count * FIXED_1;\n    }\n\n    // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n    if (x > FIXED_1) {\n      for (uint8 i = MAX_PRECISION; i > 0; --i) {\n        x = (x * x) / FIXED_1;\n        // now 1 < x < 4\n        if (x >= FIXED_2) {\n          x >>= 1;\n          // now 1 < x < 2\n          res += ONE << (i - 1);\n        }\n      }\n    }\n\n    return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n  }\n\n  /**\n   * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n   */\n  function floorLog2(uint256 _n) internal pure returns (uint8) {\n    uint8 res = 0;\n\n    if (_n < 256) {\n      // At most 8 iterations\n      while (_n > 1) {\n        _n >>= 1;\n        res += 1;\n      }\n    } else {\n      // Exactly 8 iterations\n      for (uint8 s = 128; s > 0; s >>= 1) {\n        if (_n >= (ONE << s)) {\n          _n >>= s;\n          res |= s;\n        }\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n   * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n   * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n   */\n  function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n    uint8 lo = MIN_PRECISION;\n    uint8 hi = MAX_PRECISION;\n\n    while (lo + 1 < hi) {\n      uint8 mid = (lo + hi) / 2;\n      if (maxExpArray[mid] >= _x) lo = mid;\n      else hi = mid;\n    }\n\n    if (maxExpArray[hi] >= _x) return hi;\n    if (maxExpArray[lo] >= _x) return lo;\n\n    require(false);\n    return 0;\n  }\n\n  /**\n   * @dev this function can be auto-generated by the script \"PrintFunctionGeneralExp.py\".\n   * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n   * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n   * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n   * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n   */\n  function generalExp(uint256 _x, uint8 _precision)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 xi = _x;\n    uint256 res = 0;\n\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x3442c4e6074a82f1797f72ac0000000;\n    // add x^02 * (33! / 02!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x116b96f757c380fb287fd0e40000000;\n    // add x^03 * (33! / 03!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\n    // add x^04 * (33! / 04!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00defabf91302cd95b9ffda50000000;\n    // add x^05 * (33! / 05!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x002529ca9832b22439efff9b8000000;\n    // add x^06 * (33! / 06!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00054f1cf12bd04e516b6da88000000;\n    // add x^07 * (33! / 07!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000a9e39e257a09ca2d6db51000000;\n    // add x^08 * (33! / 08!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000012e066e7b839fa050c309000000;\n    // add x^09 * (33! / 09!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000001e33d7d926c329a1ad1a800000;\n    // add x^10 * (33! / 10!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000002bee513bdb4a6b19b5f800000;\n    // add x^11 * (33! / 11!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000003a9316fa79b88eccf2a00000;\n    // add x^12 * (33! / 12!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000048177ebe1fa812375200000;\n    // add x^13 * (33! / 13!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000005263fe90242dcbacf00000;\n    // add x^14 * (33! / 14!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000000000057e22099c030d94100000;\n    // add x^15 * (33! / 15!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000057e22099c030d9410000;\n    // add x^16 * (33! / 16!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000052b6b54569976310000;\n    // add x^17 * (33! / 17!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000004985f67696bf748000;\n    // add x^18 * (33! / 18!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000000000000003dea12ea99e498000;\n    // add x^19 * (33! / 19!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000000031880f2214b6e000;\n    // add x^20 * (33! / 20!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000000000000000025bcff56eb36000;\n    // add x^21 * (33! / 21!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000000000000000001b722e10ab1000;\n    // add x^22 * (33! / 22!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000000000001317c70077000;\n    // add x^23 * (33! / 23!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000000000000cba84aafa00;\n    // add x^24 * (33! / 24!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000000000000082573a0a00;\n    // add x^25 * (33! / 25!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000000000000005035ad900;\n    // add x^26 * (33! / 26!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x000000000000000000000002f881b00;\n    // add x^27 * (33! / 27!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000000000000000001b29340;\n    // add x^28 * (33! / 28!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x00000000000000000000000000efc40;\n    // add x^29 * (33! / 29!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000000000000000000007fe0;\n    // add x^30 * (33! / 30!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000000000000000000000420;\n    // add x^31 * (33! / 31!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000000000000000000000021;\n    // add x^32 * (33! / 32!)\n    xi = (xi * _x) >> _precision;\n    res += xi * 0x0000000000000000000000000000001;\n    // add x^33 * (33! / 33!)\n\n    return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\n    // divide by 33! and then add x^1 / 1! + x^0 / 0!\n  }\n\n  /**\n   * @dev computes log(x / FIXED_1) * FIXED_1\n   * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n   * Auto-generated via \"PrintFunctionOptimalLog.py\"\n   * Detailed description:\n   * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n   * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n   * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n   * - The natural logarithm of the input is calculated by summing up the intermediate results above\n   * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n   */\n  function optimalLog(uint256 x) internal pure returns (uint256) {\n    uint256 res = 0;\n\n    uint256 y;\n    uint256 z;\n    uint256 w;\n\n    if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n      res += 0x40000000000000000000000000000000;\n      x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n    }\n    // add 1 / 2^1\n    if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n      res += 0x20000000000000000000000000000000;\n      x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n    }\n    // add 1 / 2^2\n    if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n      res += 0x10000000000000000000000000000000;\n      x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n    }\n    // add 1 / 2^3\n    if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n      res += 0x08000000000000000000000000000000;\n      x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n    }\n    // add 1 / 2^4\n    if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n      res += 0x04000000000000000000000000000000;\n      x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n    }\n    // add 1 / 2^5\n    if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n      res += 0x02000000000000000000000000000000;\n      x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n    }\n    // add 1 / 2^6\n    if (x >= 0x810100ab00222d861931c15e39b44e99) {\n      res += 0x01000000000000000000000000000000;\n      x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n    }\n    // add 1 / 2^7\n    if (x >= 0x808040155aabbbe9451521693554f733) {\n      res += 0x00800000000000000000000000000000;\n      x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n    }\n    // add 1 / 2^8\n\n    z = y = x - FIXED_1;\n    w = (y * y) / FIXED_1;\n    res +=\n      (z * (0x100000000000000000000000000000000 - y)) /\n      0x100000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^01 / 01 - y^02 / 02\n    res +=\n      (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\n      0x200000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^03 / 03 - y^04 / 04\n    res +=\n      (z * (0x099999999999999999999999999999999 - y)) /\n      0x300000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^05 / 05 - y^06 / 06\n    res +=\n      (z * (0x092492492492492492492492492492492 - y)) /\n      0x400000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^07 / 07 - y^08 / 08\n    res +=\n      (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\n      0x500000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^09 / 09 - y^10 / 10\n    res +=\n      (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\n      0x600000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^11 / 11 - y^12 / 12\n    res +=\n      (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\n      0x700000000000000000000000000000000;\n    z = (z * w) / FIXED_1;\n    // add y^13 / 13 - y^14 / 14\n    res +=\n      (z * (0x088888888888888888888888888888888 - y)) /\n      0x800000000000000000000000000000000;\n    // add y^15 / 15 - y^16 / 16\n\n    return res;\n  }\n\n  /**\n   * @dev computes e ^ (x / FIXED_1) * FIXED_1\n   * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n   * auto-generated via \"PrintFunctionOptimalExp.py\"\n   * Detailed description:\n   * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n   * - The exponentiation of each binary exponent is given (pre-calculated)\n   * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n   * - The exponentiation of the input is calculated by multiplying the intermediate results above\n   * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n   */\n  function optimalExp(uint256 x) internal pure returns (uint256) {\n    uint256 res = 0;\n\n    uint256 y;\n    uint256 z;\n\n    z = y = x % 0x10000000000000000000000000000000;\n    // get the input modulo 2^(-3)\n    z = (z * y) / FIXED_1;\n    res += z * 0x10e1b3be415a0000;\n    // add y^02 * (20! / 02!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x05a0913f6b1e0000;\n    // add y^03 * (20! / 03!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0168244fdac78000;\n    // add y^04 * (20! / 04!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x004807432bc18000;\n    // add y^05 * (20! / 05!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x000c0135dca04000;\n    // add y^06 * (20! / 06!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0001b707b1cdc000;\n    // add y^07 * (20! / 07!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x000036e0f639b800;\n    // add y^08 * (20! / 08!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x00000618fee9f800;\n    // add y^09 * (20! / 09!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000009c197dcc00;\n    // add y^10 * (20! / 10!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000000e30dce400;\n    // add y^11 * (20! / 11!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x000000012ebd1300;\n    // add y^12 * (20! / 12!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000000017499f00;\n    // add y^13 * (20! / 13!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000000001a9d480;\n    // add y^14 * (20! / 14!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x00000000001c6380;\n    // add y^15 * (20! / 15!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x000000000001c638;\n    // add y^16 * (20! / 16!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000000000001ab8;\n    // add y^17 * (20! / 17!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x000000000000017c;\n    // add y^18 * (20! / 18!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000000000000014;\n    // add y^19 * (20! / 19!)\n    z = (z * y) / FIXED_1;\n    res += z * 0x0000000000000001;\n    // add y^20 * (20! / 20!)\n    res = res / 0x21c3677c82b40000 + y + FIXED_1;\n    // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n    if ((x & 0x010000000000000000000000000000000) != 0)\n      res =\n        (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\n        0x18ebef9eac820ae8682b9793ac6d1e776;\n    // multiply by e^2^(-3)\n    if ((x & 0x020000000000000000000000000000000) != 0)\n      res =\n        (res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\n        0x1368b2fc6f9609fe7aceb46aa619baed4;\n    // multiply by e^2^(-2)\n    if ((x & 0x040000000000000000000000000000000) != 0)\n      res =\n        (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\n        0x0bc5ab1b16779be3575bd8f0520a9f21f;\n    // multiply by e^2^(-1)\n    if ((x & 0x080000000000000000000000000000000) != 0)\n      res =\n        (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\n        0x0454aaa8efe072e7f6ddbab84b40a55c9;\n    // multiply by e^2^(+0)\n    if ((x & 0x100000000000000000000000000000000) != 0)\n      res =\n        (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\n        0x00960aadc109e7a3bf4578099615711ea;\n    // multiply by e^2^(+1)\n    if ((x & 0x200000000000000000000000000000000) != 0)\n      res =\n        (res * 0x00960aadc109e7a3bf4578099615711d7) /\n        0x0002bf84208204f5977f9a8cf01fdce3d;\n    // multiply by e^2^(+2)\n    if ((x & 0x400000000000000000000000000000000) != 0)\n      res =\n        (res * 0x0002bf84208204f5977f9a8cf01fdc307) /\n        0x0000003c6ab775dd0b95b4cbee7e65d11;\n    // multiply by e^2^(+3)\n\n    return res;\n  }\n\n  function getReserveAndWeights(address pair, address tokenA)\n    public\n    view\n    override\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    )\n  {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n    uint32 tokenWeight0;\n    uint32 tokenWeight1;\n    (tokenWeight0, tokenWeight1, swapFee) = getWeightsAndSwapFee(pair);\n\n    if (tokenA == IRequiemPair(pair).token0()) {\n      (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (\n        IRequiemPair(pair).token1(),\n        reserve0,\n        reserve1,\n        tokenWeight0,\n        tokenWeight1\n      );\n    } else if (tokenA == IRequiemPair(pair).token1()) {\n      (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (\n        IRequiemPair(pair).token0(),\n        reserve1,\n        reserve0,\n        tokenWeight1,\n        tokenWeight0\n      );\n    } else {\n      revert(\"RequiemFormula: Invalid tokenA\");\n    }\n  }\n\n  function getFactoryReserveAndWeights(\n    address factory,\n    address pair,\n    address tokenA\n  )\n    public\n    view\n    override\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    )\n  {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n    uint32 tokenWeight0;\n    uint32 tokenWeight1;\n    (tokenWeight0, tokenWeight1, swapFee) = getFactoryWeightsAndSwapFee(\n      factory,\n      pair\n    );\n\n    if (tokenA == IRequiemPair(pair).token0()) {\n      (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (\n        IRequiemPair(pair).token1(),\n        reserve0,\n        reserve1,\n        tokenWeight0,\n        tokenWeight1\n      );\n    } else if (tokenA == IRequiemPair(pair).token1()) {\n      (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (\n        IRequiemPair(pair).token0(),\n        reserve1,\n        reserve0,\n        tokenWeight1,\n        tokenWeight0\n      );\n    } else {\n      revert(\"RequiemFormula: Invalid tokenA\");\n    }\n  }\n\n  /**\n   * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n   *\n   * Formula:\n   * return = reserveOut * (1 - (reserveIn * 10000 / (reserveIn * 10000 + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n   *\n   * @param amountIn                  source reserve amount\n   * @param reserveIn    source reserve balance\n   * @param reserveOut    target reserve balance\n   * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n   * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n   * @param swapFee                  swap fee of the conversion\n   *\n   * @return amountOut\n   */\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) public view override returns (uint256 amountOut) {\n    // validate input\n    require(amountIn > 0, \"RequiemFormula: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"RequiemFormula: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 amountInWithFee = amountIn * (10000 - swapFee);\n    // special case for equal weights\n    if (tokenWeightIn == tokenWeightOut) {\n      return\n        (reserveOut * amountInWithFee) / (reserveIn * 10000 + amountInWithFee);\n    }\n\n    uint256 result;\n    uint8 precision;\n    uint256 baseN = reserveIn * 10000 + amountInWithFee;\n    (result, precision) = power(\n      baseN,\n      reserveIn * 10000,\n      tokenWeightIn,\n      tokenWeightOut\n    );\n\n    uint256 temp1 = reserveOut * result;\n    uint256 temp2 = reserveOut << precision;\n    amountOut = (temp1 - temp2) / result;\n  }\n\n  /**\n   * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n   *\n   * Formula:\n   * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n   *\n   * @param amountOut     target reserve amount\n   * @param reserveIn    source reserve balance\n   * @param reserveOut    target reserve balance\n   * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n   * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n   * @param swapFee                  swap fee of the conversion\n   *\n   * @return amountIn\n   */\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) public view override returns (uint256 amountIn) {\n    // validate input\n    require(amountOut > 0, \"RequiemFormula: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"RequiemFormula: INSUFFICIENT_LIQUIDITY\"\n    );\n    // special case for equal weights\n    if (tokenWeightIn == tokenWeightOut) {\n      uint256 numerator = reserveIn * amountOut * 10000;\n      uint256 denominator = (reserveOut - amountOut) * (10000 - swapFee);\n      return numerator / denominator + 1;\n    }\n\n    uint256 result;\n    uint8 precision;\n    uint256 baseD = reserveOut - amountOut;\n    (result, precision) = power(\n      reserveOut,\n      baseD,\n      tokenWeightOut,\n      tokenWeightIn\n    );\n    uint256 baseReserveIn = reserveIn * 10000;\n    uint256 temp1 = baseReserveIn * result;\n    uint256 temp2 = baseReserveIn << precision;\n    amountIn = ((temp1 - temp2) >> precision) / (10000 - swapFee) + 1;\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view override returns (uint256[] memory amounts) {\n    require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n    amounts = new uint256[](path.length + 1);\n    amounts[0] = amountIn;\n    address currentTokenIn = tokenIn;\n    for (uint256 i = 0; i < path.length; i++) {\n      (\n        address currentTokenOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n      ) = getReserveAndWeights(path[i], currentTokenIn);\n      amounts[i + 1] = getAmountOut(\n        amounts[i],\n        reserveIn,\n        reserveOut,\n        tokenWeightIn,\n        tokenWeightOut,\n        swapFee\n      );\n      currentTokenIn = currentTokenOut;\n    }\n    require(\n      currentTokenIn == tokenOut,\n      \"RequiemFormula: INVALID_TOKEN_OUT_PATH\"\n    );\n  }\n\n  function getFactoryAmountsOut(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view override returns (uint256[] memory amounts) {\n    require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n    amounts = new uint256[](path.length + 1);\n    amounts[0] = amountIn;\n    address currentTokenIn = tokenIn;\n\n    for (uint256 i = 0; i < path.length; i++) {\n      (\n        address currentTokenOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n      ) = getFactoryReserveAndWeights(factory, path[i], currentTokenIn);\n      amounts[i + 1] = getAmountOut(\n        amounts[i],\n        reserveIn,\n        reserveOut,\n        tokenWeightIn,\n        tokenWeightOut,\n        swapFee\n      );\n      currentTokenIn = currentTokenOut;\n    }\n    require(\n      currentTokenIn == tokenOut,\n      \"RequiemFormula: INVALID_TOKEN_OUT_PATH\"\n    );\n  }\n\n  function getPairAmountOut(\n    address pair,\n    address tokenIn,\n    uint256 amountIn\n  ) external view override returns (uint256 amountOut) {\n    (\n      ,\n      uint256 reserveIn,\n      uint256 reserveOut,\n      uint32 tokenWeightIn,\n      uint32 tokenWeightOut,\n      uint32 swapFee\n    ) = getReserveAndWeights(pair, tokenIn);\n    amountOut = getAmountOut(\n      amountIn,\n      reserveIn,\n      reserveOut,\n      tokenWeightIn,\n      tokenWeightOut,\n      swapFee\n    );\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view override returns (uint256[] memory amounts) {\n    require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n    amounts = new uint256[](path.length + 1);\n    amounts[amounts.length - 1] = amountOut;\n    address currentTokenIn = tokenOut;\n    for (uint256 i = path.length; i > 0; i--) {\n      (\n        address currentTokenOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n      ) = getReserveAndWeights(path[i - 1], currentTokenIn);\n      amounts[i - 1] = getAmountIn(\n        amounts[i],\n        reserveOut,\n        reserveIn,\n        tokenWeightOut,\n        tokenWeightIn,\n        swapFee\n      );\n      currentTokenIn = currentTokenOut;\n    }\n    require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n  }\n\n  function getFactoryAmountsIn(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view override returns (uint256[] memory amounts) {\n    require(path.length > 0, \"RequiemFormula: INVALID_PATH\");\n    amounts = new uint256[](path.length + 1);\n    amounts[amounts.length - 1] = amountOut;\n    address currentTokenIn = tokenOut;\n    for (uint256 i = path.length; i > 0; i--) {\n      (\n        address currentTokenOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint32 tokenWeightIn,\n        uint32 tokenWeightOut,\n        uint32 swapFee\n      ) = getFactoryReserveAndWeights(factory, path[i - 1], currentTokenIn);\n      amounts[i - 1] = getAmountIn(\n        amounts[i],\n        reserveOut,\n        reserveIn,\n        tokenWeightOut,\n        tokenWeightIn,\n        swapFee\n      );\n      currentTokenIn = currentTokenOut;\n    }\n    require(currentTokenIn == tokenIn, \"RequiemFormula: INVALID_TOKEN_IN_PATH\");\n  }\n\n  function getPairAmountIn(\n    address pair,\n    address tokenIn,\n    uint256 amountOut\n  ) external view override returns (uint256 amountIn) {\n    (\n      ,\n      uint256 reserveIn,\n      uint256 reserveOut,\n      uint32 tokenWeightIn,\n      uint32 tokenWeightOut,\n      uint32 swapFee\n    ) = getReserveAndWeights(pair, tokenIn);\n    amountIn = getAmountIn(\n      amountOut,\n      reserveOut,\n      reserveIn,\n      tokenWeightOut,\n      tokenWeightIn,\n      swapFee\n    );\n  }\n\n  function getWeightsAndSwapFee(address pair)\n    public\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    )\n  {\n    try IRequiemPair(pair).getTokenWeights() returns (\n      uint32 _tokenWeight0,\n      uint32 _tokenWeight1\n    ) {\n      return (_tokenWeight0, _tokenWeight1, IRequiemPair(pair).getSwapFee());\n    } catch Error(string memory reason) {\n      revert(reason);\n    } catch (\n      bytes memory /*lowLevelData*/\n    ) {\n      return (50, 50, 30);\n    }\n  }\n\n  function getFactoryWeightsAndSwapFee(address factory, address pair)\n    public\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    )\n  {\n    return IRequiemFactory(factory).getWeightsAndSwapFee(pair);\n  }\n\n  // Ensure constant value reserve0^(tokenWeight0/50) * reserve1^((100 - tokenWeight0)/50) <= balance0Adjusted^(tokenWeight0/50) * balance1Adjusted^((100 - tokenWeight0)/50)\n  //  1 <= (balance0Adjusted / reserve0 )^(tokenWeight0/50) * (balance1Adjusted/reserve1)^((100 - tokenWeight0)/50)\n  //  (reserve0 / balance0Adjusted) ^ (tokenWeight0/50) <=  (balance1Adjusted / reserve1) ^ ((100 - tokenWeight0)/50)\n  function ensureConstantValue(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 balance0Adjusted,\n    uint256 balance1Adjusted,\n    uint32 tokenWeight0\n  ) external view override returns (bool) {\n    if (tokenWeight0 == 50) {\n      return balance0Adjusted * balance1Adjusted >= reserve0 * reserve1;\n    }\n    if (balance0Adjusted >= reserve0 && balance1Adjusted >= reserve1) {\n      return true;\n    }\n    if (balance0Adjusted <= reserve0 && balance1Adjusted <= reserve1) {\n      return false;\n    }\n    uint32 w0 = tokenWeight0;\n    uint32 w1 = 100 - w0;\n\n    uint256 r0;\n    uint256 p0;\n    uint256 r1;\n    uint256 p1;\n    if (balance0Adjusted >= reserve0) {\n      (r0, p0) = power(reserve1, balance1Adjusted, w1, 50);\n      (r1, p1) = power(balance0Adjusted, reserve0, w0, 50);\n    } else {\n      (r0, p0) = power(reserve0, balance0Adjusted, w0, 50);\n      (r1, p1) = power(balance1Adjusted, reserve1, w1, 50);\n    }\n    uint256 minP = p0 < p1 ? p0 : p1;\n    p0 = p0 - minP;\n    p1 = p1 - minP;\n    return (r0 >> p0) <= (r1 >> p1);\n  }\n\n  function sortTokens(address tokenA, address tokenB)\n    public\n    pure\n    override\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"RequiemFormula: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"RequiemFormula: ZERO_ADDRESS\");\n  }\n\n  function getReserves(\n    address pair,\n    address tokenA,\n    address tokenB\n  ) external view override returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(pair).getReserves();\n    require(\n      token0 == IRequiemPair(pair).token0() &&\n        token1 == IRequiemPair(pair).token1(),\n      \"RequiemFormula: Invalid token\"\n    );\n    (reserveA, reserveB) = tokenA == token0\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n  function getOtherToken(address pair, address tokenA)\n    external\n    view\n    override\n    returns (address tokenB)\n  {\n    address token0 = IRequiemPair(pair).token0();\n    address token1 = IRequiemPair(pair).token1();\n    require(\n      token0 == tokenA || token1 == tokenA,\n      \"RequiemFormula: Invalid tokenA\"\n    );\n    tokenB = token0 == tokenA ? token1 : token0;\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure override returns (uint256 amountB) {\n    require(amountA > 0, \"RequiemFormula: INSUFFICIENT_AMOUNT\");\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"RequiemFormula: INSUFFICIENT_LIQUIDITY\"\n    );\n    amountB = (amountA * reserveB) / reserveA;\n  }\n\n  function mintLiquidityFee(\n    uint256 totalLiquidity,\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 tokenWeight0,\n    uint32 tokenWeight1,\n    uint112 collectedFee0,\n    uint112 collectedFee1\n  ) external view override returns (uint256 amount) {\n    if (collectedFee0 > 0) {\n      (uint256 r0, uint256 p0) = power(\n        uint256(collectedFee0) + reserve0,\n        reserve0,\n        tokenWeight0,\n        100\n      );\n      amount = amount + ((totalLiquidity * r0) >> p0) - totalLiquidity;\n    }\n    if (collectedFee1 > 0) {\n      (uint256 r1, uint256 p1) = power(\n        uint256(collectedFee1) + reserve1,\n        reserve1,\n        tokenWeight1,\n        100\n      );\n      amount = amount + ((totalLiquidity * r1) >> p1) - totalLiquidity;\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}