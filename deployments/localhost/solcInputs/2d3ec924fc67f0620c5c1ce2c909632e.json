{
  "language": "Solidity",
  "sources": {
    "contracts/test/RequiemQPairManager_flat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// File: interfaces/IRequiemQPairManager.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemQPairManager {\n  function factory() external view returns (address);\n\n  function formula() external view returns (address);\n\n  function WETH() external view returns (address);\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint256 amountA,\n    uint256 amountB,\n    uint32 tokenWeightA,\n    uint32 swapFee,\n    address to\n  ) external returns (uint256 liquidity);\n\n  function createPairETH(\n    address token,\n    uint256 amountToken,\n    uint32 tokenWeight,\n    uint32 swapFee,\n    address to\n  ) external payable returns (uint256 liquidity);\n\n  function addLiquidity(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n\n  function addLiquidityETH(\n    address pair,\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    );\n\n  function removeLiquidity(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETHWithPermit(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n}\n\n// File: interfaces/ERC20/IERC20.sol\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: interfaces/IWETH.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface for WETH9.\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\n */\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n\n  function withdraw(uint256 amount) external;\n}\n\n// File: libraries/TransferHelper.sol\n\npragma solidity >=0.8.11;\n\n// solhint-disable avoid-low-level-calls, reason-string\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n  function safeApprove(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x095ea7b3, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: APPROVE_FAILED\"\n    );\n  }\n\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0xa9059cbb, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FAILED\"\n    );\n  }\n\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FROM_FAILED\"\n    );\n  }\n\n  function safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n  }\n}\n\n// File: interfaces/IRequiemSwap.sol\n\npragma solidity ^0.8.11;\n\ninterface IRequiemSwap {\n  // this funtion requires the correctly calculated amounts as input\n  // the others are supposed to implement that calculation\n  // no return value required since the amounts are already known\n  function onSwap(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOut,\n    address to\n  ) external;\n\n  //\n  function onSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to\n  ) external returns (uint256);\n\n  function onSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address to\n  ) external returns (uint256);\n\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n}\n\n// File: interfaces/IRequiemERC20.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\n// File: interfaces/IRequiemPair.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPair is IRequiemERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n\n// File: interfaces/IRequiemFormula.sol\n\npragma solidity >=0.8.11;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n  function getReserveAndWeights(address pair, address tokenA)\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getFactoryReserveAndWeights(\n    address factory,\n    address pair,\n    address tokenA\n  )\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountIn);\n\n  function getPairAmountIn(\n    address pair,\n    address tokenIn,\n    uint256 amountOut\n  ) external view returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountOut);\n\n  function getPairAmountOut(\n    address pair,\n    address tokenIn,\n    uint256 amountIn\n  ) external view returns (uint256 amountOut);\n\n  function getAmountsIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsIn(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getAmountsOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsOut(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function ensureConstantValue(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 balance0Adjusted,\n    uint256 balance1Adjusted,\n    uint32 tokenWeight0\n  ) external view returns (bool);\n\n  function getReserves(\n    address pair,\n    address tokenA,\n    address tokenB\n  ) external view returns (uint256 reserveA, uint256 reserveB);\n\n  function getOtherToken(address pair, address tokenA)\n    external\n    view\n    returns (address tokenB);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function sortTokens(address tokenA, address tokenB)\n    external\n    pure\n    returns (address token0, address token1);\n\n  function mintLiquidityFee(\n    uint256 totalLiquidity,\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 tokenWeight0,\n    uint32 tokenWeight1,\n    uint112 collectedFee0,\n    uint112 collectedFee1\n  ) external view returns (uint256 amount);\n}\n\n// File: interfaces/IRequiemFactory.sol\n\npragma solidity >=0.5.16;\n\ninterface IRequiemFactory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint32 tokenWeight0,\n    uint32 swapFee,\n    uint256\n  );\n\n  function feeTo() external view returns (address);\n\n  function formula() external view returns (address);\n\n  function protocolFee() external view returns (uint256);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function isPair(address) external view returns (bool);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external returns (address pair);\n\n  function getWeightsAndSwapFee(address pair)\n    external\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    );\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  function setProtocolFee(uint256) external;\n}\n\n// File: RequiemQPairManager.sol\n\npragma solidity >=0.8.11;\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemQPairManager is IRequiemQPairManager {\n  address public immutable override factory;\n  address public immutable override formula;\n  address public immutable override WETH;\n  address private constant ETH_ADDRESS =\n    address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n  modifier ensure(uint256 deadline) {\n    require(deadline >= block.timestamp, \"Router: EXPIRED\");\n    _;\n  }\n\n  constructor(address _factory, address _WETH) {\n    factory = _factory;\n    formula = IRequiemFactory(_factory).formula();\n    WETH = _WETH;\n  }\n\n  receive() external payable {\n    assert(msg.sender == WETH);\n    // only accept ETH via fallback from the WETH contract\n  }\n\n  // **** ADD LIQUIDITY ****\n  function _addLiquidity(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin\n  ) internal virtual returns (uint256 amountA, uint256 amountB) {\n    (uint256 reserveA, uint256 reserveB) = IRequiemFormula(formula).getReserves(\n      pair,\n      tokenA,\n      tokenB\n    );\n    if (reserveA == 0 && reserveB == 0) {\n      (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n      uint256 amountBOptimal = IRequiemFormula(formula).quote(\n        amountADesired,\n        reserveA,\n        reserveB\n      );\n      if (amountBOptimal <= amountBDesired) {\n        require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n        (amountA, amountB) = (amountADesired, amountBOptimal);\n      } else {\n        uint256 amountAOptimal = IRequiemFormula(formula).quote(\n          amountBDesired,\n          reserveB,\n          reserveA\n        );\n        assert(amountAOptimal <= amountADesired);\n        require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\n      }\n    }\n  }\n\n  function _addLiquidityToken(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin\n  ) internal returns (uint256 amountA, uint256 amountB) {\n    (amountA, amountB) = _addLiquidity(\n      pair,\n      tokenA,\n      tokenB,\n      amountADesired,\n      amountBDesired,\n      amountAMin,\n      amountBMin\n    );\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n  }\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint256 amountA,\n    uint256 amountB,\n    uint32 tokenWeightA,\n    uint32 swapFee,\n    address to\n  ) public virtual override returns (uint256 liquidity) {\n    address pair = IRequiemFactory(factory).createPair(\n      tokenA,\n      tokenB,\n      tokenWeightA,\n      swapFee\n    );\n    _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n    liquidity = IRequiemPair(pair).mint(to);\n  }\n\n  function addLiquidity(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    )\n  {\n    (amountA, amountB) = _addLiquidityToken(\n      pair,\n      tokenA,\n      tokenB,\n      amountADesired,\n      amountBDesired,\n      amountAMin,\n      amountBMin\n    );\n    liquidity = IRequiemPair(pair).mint(to);\n  }\n\n  function _addLiquidityETH(\n    address pair,\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to\n  )\n    internal\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    )\n  {\n    (amountToken, amountETH) = _addLiquidity(\n      pair,\n      token,\n      WETH,\n      amountTokenDesired,\n      msg.value,\n      amountTokenMin,\n      amountETHMin\n    );\n    TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n    transferETHTo(amountETH, pair);\n    liquidity = IRequiemPair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH)\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n  }\n\n  function createPairETH(\n    address token,\n    uint256 amountToken,\n    uint32 tokenWeight,\n    uint32 swapFee,\n    address to\n  ) public payable virtual override returns (uint256 liquidity) {\n    address pair = IRequiemFactory(factory).createPair(\n      token,\n      WETH,\n      tokenWeight,\n      swapFee\n    );\n    (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n  }\n\n  function addLiquidityETH(\n    address pair,\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    public\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    )\n  {\n    (amountToken, amountETH, liquidity) = _addLiquidityETH(\n      pair,\n      token,\n      amountTokenDesired,\n      amountTokenMin,\n      amountETHMin,\n      to\n    );\n  }\n\n  // **** REMOVE LIQUIDITY ****\n  function _removeLiquidity(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to\n  ) internal returns (uint256 amountA, uint256 amountB) {\n    require(IRequiemFactory(factory).isPair(pair), \"Router: Invalid pair\");\n    IRequiemPair(pair).transferFrom(msg.sender, pair, liquidity);\n    // send liquidity to pair\n    (uint256 amount0, uint256 amount1) = IRequiemPair(pair).burn(to);\n    (address token0, ) = IRequiemFormula(formula).sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0\n      ? (amount0, amount1)\n      : (amount1, amount0);\n    require(amountA >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n    require(amountB >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n  }\n\n  function removeLiquidity(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    public\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256 amountA, uint256 amountB)\n  {\n    (amountA, amountB) = _removeLiquidity(\n      pair,\n      tokenA,\n      tokenB,\n      liquidity,\n      amountAMin,\n      amountBMin,\n      to\n    );\n  }\n\n  function removeLiquidityETH(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    public\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256 amountToken, uint256 amountETH)\n  {\n    (amountToken, amountETH) = _removeLiquidity(\n      pair,\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this)\n    );\n    TransferHelper.safeTransfer(token, to, amountToken);\n    transferAll(ETH_ADDRESS, to, amountETH);\n  }\n\n  function removeLiquidityWithPermit(\n    address pair,\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256 amountA, uint256 amountB)\n  {\n    {\n      uint256 value = approveMax ? type(uint256).max : liquidity;\n      IRequiemPair(pair).permit(\n        msg.sender,\n        address(this),\n        value,\n        deadline,\n        v,\n        r,\n        s\n      );\n    }\n    (amountA, amountB) = _removeLiquidity(\n      pair,\n      tokenA,\n      tokenB,\n      liquidity,\n      amountAMin,\n      amountBMin,\n      to\n    );\n  }\n\n  function removeLiquidityETHWithPermit(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\n    uint256 value = approveMax ? type(uint256).max : liquidity;\n    IRequiemPair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountToken, amountETH) = removeLiquidityETH(\n      pair,\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }\n\n  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n    (, amountETH) = removeLiquidity(\n      pair,\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    TransferHelper.safeTransfer(\n      token,\n      to,\n      IERC20(token).balanceOf(address(this))\n    );\n    transferAll(ETH_ADDRESS, to, amountETH);\n  }\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address pair,\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint256 amountETH) {\n    uint256 value = approveMax ? type(uint256).max : liquidity;\n    IRequiemPair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n      pair,\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }\n\n  function transferETHTo(uint256 amount, address to) internal {\n    IWETH(WETH).deposit{value: amount}();\n    assert(IWETH(WETH).transfer(to, amount));\n  }\n\n  function transferAll(\n    address token,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n    if (amount == 0) {\n      return true;\n    }\n\n    if (isETH(token)) {\n      IWETH(WETH).withdraw(amount);\n      TransferHelper.safeTransferETH(to, amount);\n    } else {\n      TransferHelper.safeTransfer(token, to, amount);\n    }\n    return true;\n  }\n\n  function isETH(address token) internal pure returns (bool) {\n    return (token == ETH_ADDRESS);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}