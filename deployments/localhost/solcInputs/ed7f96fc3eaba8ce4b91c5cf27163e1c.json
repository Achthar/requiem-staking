{
  "language": "Solidity",
  "sources": {
    "contracts/test/RequiemQRouter_flat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// File: interfaces/IRequiemQRouter.sol\n\npragma solidity ^0.8.11;\n\ninterface IRequiemQRouter {\n  event Exchange(address pair, uint256 amountOut, address output);\n  struct Swap {\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    uint256 swapAmount; // tokenInAmount / tokenOutAmount\n    uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n    uint256 maxPrice;\n  }\n\n  function factory() external view returns (address);\n\n  function formula() external view returns (address);\n\n  function WETH() external view returns (address);\n\n  function swapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    address tokenOut,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapTokensForExactETH(\n    address tokenIn,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETH(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapETHForExactTokens(\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    address tokenOut,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function multihopBatchSwapExactIn(\n    Swap[][] memory swapSequences,\n    address tokenIn,\n    address tokenOut,\n    uint256 totalAmountIn,\n    uint256 minTotalAmountOut,\n    uint256 deadline\n  ) external payable returns (uint256 totalAmountOut);\n\n  function multihopBatchSwapExactOut(\n    Swap[][] memory swapSequences,\n    address tokenIn,\n    address tokenOut,\n    uint256 maxTotalAmountIn,\n    uint256 deadline\n  ) external payable returns (uint256 totalAmountIn);\n}\n\n// File: interfaces/ERC20/IERC20.sol\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: interfaces/IWETH.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface for WETH9.\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\n */\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n\n  function withdraw(uint256 amount) external;\n}\n\n// File: libraries/TransferHelper.sol\n\npragma solidity >=0.8.11;\n\n// solhint-disable avoid-low-level-calls, reason-string\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n  function safeApprove(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x095ea7b3, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: APPROVE_FAILED\"\n    );\n  }\n\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0xa9059cbb, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FAILED\"\n    );\n  }\n\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TransferHelper: TRANSFER_FROM_FAILED\"\n    );\n  }\n\n  function safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n  }\n}\n\n// File: interfaces/IRequiemSwap.sol\n\npragma solidity ^0.8.11;\n\ninterface IRequiemSwap {\n  // this funtion requires the correctly calculated amounts as input\n  // the others are supposed to implement that calculation\n  // no return value required since the amounts are already known\n  function onSwap(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOut,\n    address to\n  ) external;\n\n  //\n  function onSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to\n  ) external returns (uint256);\n\n  function onSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address to\n  ) external returns (uint256);\n\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n}\n\n// File: interfaces/IRequiemERC20.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\n// File: interfaces/IRequiemPair.sol\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPair is IRequiemERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n\n// File: interfaces/IRequiemFormula.sol\n\npragma solidity >=0.8.11;\n\n/*\n    Bancor Formula interface\n*/\ninterface IRequiemFormula {\n  function getReserveAndWeights(address pair, address tokenA)\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getFactoryReserveAndWeights(\n    address factory,\n    address pair,\n    address tokenA\n  )\n    external\n    view\n    returns (\n      address tokenB,\n      uint256 reserveA,\n      uint256 reserveB,\n      uint32 tokenWeightA,\n      uint32 tokenWeightB,\n      uint32 swapFee\n    );\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountIn);\n\n  function getPairAmountIn(\n    address pair,\n    address tokenIn,\n    uint256 amountOut\n  ) external view returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint32 tokenWeightIn,\n    uint32 tokenWeightOut,\n    uint32 swapFee\n  ) external view returns (uint256 amountOut);\n\n  function getPairAmountOut(\n    address pair,\n    address tokenIn,\n    uint256 amountIn\n  ) external view returns (uint256 amountOut);\n\n  function getAmountsIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsIn(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getAmountsOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getFactoryAmountsOut(\n    address factory,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function ensureConstantValue(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 balance0Adjusted,\n    uint256 balance1Adjusted,\n    uint32 tokenWeight0\n  ) external view returns (bool);\n\n  function getReserves(\n    address pair,\n    address tokenA,\n    address tokenB\n  ) external view returns (uint256 reserveA, uint256 reserveB);\n\n  function getOtherToken(address pair, address tokenA)\n    external\n    view\n    returns (address tokenB);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function sortTokens(address tokenA, address tokenB)\n    external\n    pure\n    returns (address token0, address token1);\n\n  function mintLiquidityFee(\n    uint256 totalLiquidity,\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 tokenWeight0,\n    uint32 tokenWeight1,\n    uint112 collectedFee0,\n    uint112 collectedFee1\n  ) external view returns (uint256 amount);\n}\n\n// File: interfaces/IRequiemFactory.sol\n\npragma solidity >=0.5.16;\n\ninterface IRequiemFactory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint32 tokenWeight0,\n    uint32 swapFee,\n    uint256\n  );\n\n  function feeTo() external view returns (address);\n\n  function formula() external view returns (address);\n\n  function protocolFee() external view returns (uint256);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function isPair(address) external view returns (bool);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(\n    address tokenA,\n    address tokenB,\n    uint32 tokenWeightA,\n    uint32 swapFee\n  ) external returns (address pair);\n\n  function getWeightsAndSwapFee(address pair)\n    external\n    view\n    returns (\n      uint32 tokenWeight0,\n      uint32 tokenWeight1,\n      uint32 swapFee\n    );\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  function setProtocolFee(uint256) external;\n}\n\n// File: RequiemQRouter.sol\n\npragma solidity >=0.8.11;\n\n// solhint-disable not-rely-on-time, var-name-mixedcase, max-line-length, reason-string\n\ncontract RequiemQRouter is IRequiemQRouter {\n  address public immutable override factory;\n  address public immutable override formula;\n  address public immutable override WETH;\n  address private constant ETH_ADDRESS =\n    address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n  modifier ensure(uint256 deadline) {\n    require(deadline >= block.timestamp, \"Router: EXPIRED\");\n    _;\n  }\n\n  constructor(address _factory, address _WETH) {\n    factory = _factory;\n    formula = IRequiemFactory(_factory).formula();\n    WETH = _WETH;\n  }\n\n  receive() external payable {\n    assert(msg.sender == WETH);\n    // only accept ETH via fallback from the WETH contract\n  }\n\n  // **** SWAP ****\n  // requires the initial amount to have already been sent to the first pair\n  function _swap(\n    address tokenIn,\n    uint256[] memory amounts,\n    address[] memory path,\n    address _to\n  ) internal virtual {\n    address input = tokenIn;\n    for (uint256 i = 0; i < path.length; i++) {\n      IRequiemPair pairV2 = IRequiemPair(path[i]);\n      address token0 = pairV2.token0();\n      uint256 amountOut = amounts[i + 1];\n      (uint256 amount0Out, uint256 amount1Out, address output) = input == token0\n        ? (uint256(0), amountOut, pairV2.token1())\n        : (amountOut, uint256(0), token0);\n      address to = i < path.length - 1 ? path[i + 1] : _to;\n      pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\n      emit Exchange(address(pairV2), amountOut, output);\n      input = output;\n    }\n  }\n\n  function swapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  )\n    public\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = _validateAmountOut(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      amountOutMin,\n      path\n    );\n    TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n    _swap(tokenIn, amounts, path, to);\n  }\n\n  // the onSwap functions are designed to include the stable swap\n  // it currenty only allows exactIn structures\n  function onSwapExactTokensForTokens(\n    address[] memory pools,\n    address[] memory tokens,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) public virtual ensure(deadline) returns (uint256 amountLast) {\n    amountLast = amountIn;\n    TransferHelper.safeTransferFrom(tokens[0], msg.sender, pools[0], amountIn);\n    for (uint256 i = 0; i < pools.length; i++) {\n      address _to = i == pools.length - 1 ? to : pools[i + 1];\n      amountLast = IRequiemSwap(pools[i]).onSwapGivenIn(\n        tokens[i],\n        tokens[i + 1],\n        amountLast,\n        0,\n        _to\n      );\n    }\n    require(amountOutMin <= amountLast, \"INSUFFICIENT_OUTPUT\");\n  }\n\n  function onSwapExactETHForTokens(\n    address[] memory pools,\n    address[] memory tokens,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external payable virtual ensure(deadline) returns (uint256 amountLast) {\n    amountLast = msg.value;\n    transferETHTo(msg.value, pools[0]);\n    for (uint256 i = 0; i < pools.length; i++) {\n      address _to = i == pools.length - 1 ? to : pools[i + 1];\n      amountLast = IRequiemSwap(pools[i]).onSwapGivenIn(\n        tokens[i],\n        tokens[i + 1],\n        amountLast,\n        0,\n        _to\n      );\n    }\n    require(amountOutMin <= amountLast, \"INSUFFICIENT_OUTPUT\");\n  }\n\n  function onSwapExactTokensForETH(\n    address[] memory pools,\n    address[] memory tokens,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external virtual ensure(deadline) returns (uint256 amountLast) {\n    amountLast = amountIn;\n    TransferHelper.safeTransferFrom(tokens[0], msg.sender, pools[0], amountIn);\n    for (uint256 i = 0; i < pools.length; i++) {\n      address _to = i == pools.length - 1 ? address(this) : pools[i + 1];\n      amountLast = IRequiemSwap(pools[i]).onSwapGivenIn(\n        tokens[i],\n        tokens[i + 1],\n        amountLast,\n        0,\n        _to\n      );\n    }\n    require(amountOutMin <= amountLast, \"INSUFFICIENT_OUTPUT\");\n    transferAll(ETH_ADDRESS, to, amountLast);\n  }\n\n  // direct swap function for given exact output\n  function onSwapTokensForExactTokens(\n    address[] memory pools,\n    address[] memory tokens,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address to,\n    uint256 deadline\n  ) external virtual ensure(deadline) returns (uint256[] memory amounts) {\n    // set amount array\n    amounts = new uint256[](tokens.length);\n    amounts[pools.length] = amountOut;\n\n    // calculate all amounts to be sent and recieved\n    for (uint256 i = amounts.length - 1; i > 0; i--) {\n      amounts[i - 1] = IRequiemSwap(pools[i - 1]).calculateSwapGivenOut(\n        tokens[i - 1],\n        tokens[i],\n        amounts[i]\n      );\n    }\n\n    // check input condition\n    require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT\");\n\n    // tranfer amounts\n    TransferHelper.safeTransferFrom(\n      tokens[0],\n      msg.sender,\n      pools[0],\n      amounts[0]\n    );\n\n    // use general swap functions that do not execute the full calculation to save gas\n    for (uint256 i = 0; i < pools.length; i++) {\n      address _to = i == pools.length - 1 ? to : pools[i + 1];\n      IRequiemSwap(pools[i]).onSwap(\n        tokens[i],\n        tokens[i + 1],\n        amounts[i],\n        amounts[i + 1],\n        _to\n      );\n    }\n  }\n\n  function onSwapETHForExactTokens(\n    address[] memory pools,\n    address[] memory tokens,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    virtual\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = new uint256[](tokens.length);\n    amounts[pools.length] = amountOut;\n    for (uint256 i = amounts.length - 1; i > 0; i--) {\n      amounts[i - 1] = IRequiemSwap(pools[i - 1]).calculateSwapGivenOut(\n        tokens[i - 1],\n        tokens[i],\n        amounts[i]\n      );\n    }\n\n    require(amounts[0] <= msg.value, \"EXCESSIVE_INPUT\");\n\n    transferETHTo(amounts[0], pools[0]);\n    for (uint256 i = 0; i < pools.length; i++) {\n      address _to = i == pools.length - 1 ? to : pools[i + 1];\n      IRequiemSwap(pools[i]).onSwap(\n        tokens[i],\n        tokens[i + 1],\n        amounts[i],\n        amounts[i + 1],\n        _to\n      );\n    }\n    // refund dust eth, if any\n    if (msg.value > amounts[0])\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n  }\n\n  function onSwapTokensForExactETH(\n    address[] memory pools,\n    address[] memory tokens,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address to,\n    uint256 deadline\n  ) external virtual ensure(deadline) returns (uint256[] memory amounts) {\n    amounts = new uint256[](tokens.length);\n    amounts[pools.length] = amountOut;\n    for (uint256 i = amounts.length - 1; i > 0; i--) {\n      amounts[i - 1] = IRequiemSwap(pools[i - 1]).calculateSwapGivenOut(\n        tokens[i - 1],\n        tokens[i],\n        amounts[i]\n      );\n    }\n\n    require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT\");\n    TransferHelper.safeTransferFrom(\n      tokens[0],\n      msg.sender,\n      pools[0],\n      amounts[0]\n    );\n    for (uint256 i = 0; i < pools.length; i++) {\n      address _to = i == pools.length - 1 ? address(this) : pools[i + 1];\n      IRequiemSwap(pools[i]).onSwap(\n        tokens[i],\n        tokens[i + 1],\n        amounts[i],\n        amounts[i + 1],\n        _to\n      );\n    }\n\n    transferAll(ETH_ADDRESS, to, amountOut);\n  }\n\n  function swapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = _validateAmountIn(\n      tokenIn,\n      tokenOut,\n      amountOut,\n      amountInMax,\n      path\n    );\n\n    TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n    _swap(tokenIn, amounts, path, to);\n  }\n\n  function swapExactETHForTokens(\n    address tokenOut,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n    transferETHTo(amounts[0], path[0]);\n    _swap(WETH, amounts, path, to);\n  }\n\n  function swapTokensForExactETH(\n    address tokenIn,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n    TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n    _swap(tokenIn, amounts, path, address(this));\n    transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n  }\n\n  function swapExactTokensForETH(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n    TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\n    _swap(tokenIn, amounts, path, address(this));\n    transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n  }\n\n  function swapETHForExactTokens(\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256[] memory amounts)\n  {\n    amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n    transferETHTo(amounts[0], path[0]);\n    _swap(WETH, amounts, path, to);\n    // refund dust eth, if any\n    if (msg.value > amounts[0])\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n  }\n\n  // **** SWAP (supporting fee-on-transfer tokens) ****\n  // requires the initial amount to have already been sent to the first pair\n  function _swapSupportingFeeOnTransferTokens(\n    address tokenIn,\n    address[] memory path,\n    address _to\n  ) internal virtual {\n    address input = tokenIn;\n    for (uint256 i; i < path.length; i++) {\n      IRequiemPair pair = IRequiemPair(path[i]);\n      uint256 amountInput;\n      uint256 amountOutput;\n      address currentOutput;\n      {\n        (\n          address output,\n          uint256 reserveInput,\n          uint256 reserveOutput,\n          uint32 tokenWeightInput,\n          uint32 tokenWeightOutput,\n          uint32 swapFee\n        ) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n            factory,\n            address(pair),\n            input\n          );\n        amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\n        amountOutput = IRequiemFormula(formula).getAmountOut(\n          amountInput,\n          reserveInput,\n          reserveOutput,\n          tokenWeightInput,\n          tokenWeightOutput,\n          swapFee\n        );\n        currentOutput = output;\n      }\n      (uint256 amount0Out, uint256 amount1Out) = input == pair.token0()\n        ? (uint256(0), amountOutput)\n        : (amountOutput, uint256(0));\n      address to = i < path.length - 1 ? path[i + 1] : _to;\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\n      emit Exchange(address(pair), amountOutput, currentOutput);\n      input = currentOutput;\n    }\n  }\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external virtual override ensure(deadline) {\n    TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n    uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n    require(\n      IERC20(tokenOut).balanceOf(to) - balanceBefore >= amountOutMin,\n      \"Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    address tokenOut,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable virtual override ensure(deadline) {\n    //            require(path[0] == WETH, \"Router: INVALID_PATH\");\n    uint256 amountIn = msg.value;\n    transferETHTo(amountIn, path[0]);\n    uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(WETH, path, to);\n    require(\n      IERC20(tokenOut).balanceOf(to) - balanceBefore >= amountOutMin,\n      \"Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external virtual override ensure(deadline) {\n    TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\n    _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n    uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n    require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    transferAll(ETH_ADDRESS, to, amountOut);\n  }\n\n  function multihopBatchSwapExactIn(\n    Swap[][] memory swapSequences,\n    address tokenIn,\n    address tokenOut,\n    uint256 totalAmountIn,\n    uint256 minTotalAmountOut,\n    uint256 deadline\n  )\n    public\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256 totalAmountOut)\n  {\n    transferFromAll(tokenIn, totalAmountIn);\n    uint256 balanceBefore;\n    if (!isETH(tokenOut)) {\n      balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n    }\n\n    for (uint256 i = 0; i < swapSequences.length; i++) {\n      uint256 tokenAmountOut;\n      for (uint256 k = 0; k < swapSequences[i].length; k++) {\n        Swap memory swap = swapSequences[i][k];\n        if (k > 0) {\n          // Makes sure that on the second swap the output of the first was used\n          // so there is not intermediate token leftover\n          swap.swapAmount = tokenAmountOut;\n        }\n        tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(\n          swap.tokenIn,\n          swap.tokenOut,\n          swap.pool,\n          swap.swapAmount,\n          swap.limitReturnAmount\n        );\n      }\n\n      // This takes the amountOut of the last swap\n      tokenAmountOut += totalAmountOut;\n    }\n\n    transferAll(tokenOut, msg.sender, totalAmountOut);\n    transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n    if (isETH(tokenOut)) {\n      require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n    } else {\n      require(\n        IERC20(tokenOut).balanceOf(msg.sender) - balanceBefore >=\n          minTotalAmountOut,\n        \"<minTotalAmountOut\"\n      );\n    }\n  }\n\n  function multihopBatchSwapExactOut(\n    Swap[][] memory swapSequences,\n    address tokenIn,\n    address tokenOut,\n    uint256 maxTotalAmountIn,\n    uint256 deadline\n  )\n    public\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint256 totalAmountIn)\n  {\n    transferFromAll(tokenIn, maxTotalAmountIn);\n\n    for (uint256 i = 0; i < swapSequences.length; i++) {\n      uint256 tokenAmountInFirstSwap;\n      // Specific code for a simple swap and a multihop (2 swaps in sequence)\n      if (swapSequences[i].length == 1) {\n        Swap memory swap = swapSequences[i][0];\n        tokenAmountInFirstSwap = _swapSingleMixOut(\n          swap.tokenIn,\n          swap.tokenOut,\n          swap.pool,\n          swap.swapAmount,\n          swap.limitReturnAmount\n        );\n      } else {\n        // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n        // of token C. But first we need to buy B with A so we can then buy C with B\n        // To get the exact amount of C we then first need to calculate how much B we\"ll need:\n        uint256 intermediateTokenAmount;\n        // This would be token B as described above\n        Swap memory secondSwap = swapSequences[i][1];\n        {\n          address[] memory paths = new address[](1);\n          paths[0] = secondSwap.pool;\n          uint256[] memory amounts = IRequiemFormula(formula)\n            .getFactoryAmountsIn(\n              factory,\n              secondSwap.tokenIn,\n              secondSwap.tokenOut,\n              secondSwap.swapAmount,\n              paths\n            );\n          intermediateTokenAmount = amounts[0];\n          require(\n            intermediateTokenAmount <= secondSwap.limitReturnAmount,\n            \"Router: EXCESSIVE_INPUT_AMOUNT\"\n          );\n        }\n\n        //// Buy intermediateTokenAmount of token B with A in the first pool\n        Swap memory firstSwap = swapSequences[i][0];\n        tokenAmountInFirstSwap = _swapSingleMixOut(\n          firstSwap.tokenIn,\n          firstSwap.tokenOut,\n          firstSwap.pool,\n          intermediateTokenAmount,\n          firstSwap.limitReturnAmount\n        );\n\n        //// Buy the final amount of token C desired\n        _swapSingle(\n          secondSwap.tokenIn,\n          secondSwap.pool,\n          intermediateTokenAmount,\n          secondSwap.swapAmount\n        );\n      }\n\n      totalAmountIn += tokenAmountInFirstSwap;\n    }\n\n    require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n    transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n    transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n  }\n\n  function transferFromAll(address token, uint256 amount)\n    internal\n    returns (bool)\n  {\n    if (isETH(token)) {\n      IWETH(WETH).deposit{value: msg.value}();\n    } else {\n      TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n    }\n    return true;\n  }\n\n  function getBalance(address token) internal view returns (uint256) {\n    if (isETH(token)) {\n      return IWETH(WETH).balanceOf(address(this));\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n\n  function _swapSingleMixOut(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    uint256 swapAmount,\n    uint256 limitReturnAmount\n  ) internal returns (uint256 tokenAmountIn) {\n    address[] memory paths = new address[](1);\n    paths[0] = pool;\n    uint256[] memory amounts = IRequiemFormula(formula).getFactoryAmountsIn(\n      factory,\n      tokenIn,\n      tokenOut,\n      swapAmount,\n      paths\n    );\n    tokenAmountIn = amounts[0];\n    require(\n      tokenAmountIn <= limitReturnAmount,\n      \"Router: EXCESSIVE_INPUT_AMOUNT\"\n    );\n    _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n  }\n\n  function _swapSingle(\n    address tokenIn,\n    address pair,\n    uint256 targetSwapAmount,\n    uint256 targetOutAmount\n  ) internal {\n    TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n    IRequiemPair pairV2 = IRequiemPair(pair);\n    address token0 = pairV2.token0();\n\n    (uint256 amount0Out, uint256 amount1Out, address output) = tokenIn == token0\n      ? (uint256(0), targetOutAmount, pairV2.token1())\n      : (targetOutAmount, uint256(0), token0);\n    pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n    emit Exchange(pair, targetOutAmount, output);\n  }\n\n  function _swapSingleSupportFeeOnTransferTokens(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    uint256 swapAmount,\n    uint256 limitReturnAmount\n  ) internal returns (uint256 tokenAmountOut) {\n    TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n    uint256 amountOutput;\n    {\n      (\n        ,\n        uint256 reserveInput,\n        uint256 reserveOutput,\n        uint32 tokenWeightInput,\n        uint32 tokenWeightOutput,\n        uint32 swapFee\n      ) = IRequiemFormula(formula).getFactoryReserveAndWeights(\n          factory,\n          pool,\n          tokenIn\n        );\n      uint256 amountInput = IERC20(tokenIn).balanceOf(pool) - reserveInput;\n      amountOutput = IRequiemFormula(formula).getAmountOut(\n        amountInput,\n        reserveInput,\n        reserveOutput,\n        tokenWeightInput,\n        tokenWeightOutput,\n        swapFee\n      );\n    }\n    uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n    (uint256 amount0Out, uint256 amount1Out) = tokenIn ==\n      IRequiemPair(pool).token0()\n      ? (uint256(0), amountOutput)\n      : (amountOutput, uint256(0));\n    IRequiemPair(pool).swap(\n      amount0Out,\n      amount1Out,\n      address(this),\n      new bytes(0)\n    );\n    emit Exchange(pool, amountOutput, tokenOut);\n\n    tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)) - balanceBefore;\n    require(\n      tokenAmountOut >= limitReturnAmount,\n      \"Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function _validateAmountOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    amounts = IRequiemFormula(formula).getFactoryAmountsOut(\n      factory,\n      tokenIn,\n      tokenOut,\n      amountIn,\n      path\n    );\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function _calculateAmountOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    amounts = IRequiemFormula(formula).getFactoryAmountsOut(\n      factory,\n      tokenIn,\n      tokenOut,\n      amountIn,\n      path\n    );\n  }\n\n  function _validateAmountIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    amounts = IRequiemFormula(formula).getFactoryAmountsIn(\n      factory,\n      tokenIn,\n      tokenOut,\n      amountOut,\n      path\n    );\n    require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\n  }\n\n  // the same as _validateAmountIn, just with no requirement checking\n  function _calculateAmountIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    amounts = IRequiemFormula(formula).getFactoryAmountsIn(\n      factory,\n      tokenIn,\n      tokenOut,\n      amountOut,\n      path\n    );\n  }\n\n  function transferETHTo(uint256 amount, address to) internal {\n    IWETH(WETH).deposit{value: amount}();\n    assert(IWETH(WETH).transfer(to, amount));\n  }\n\n  function transferAll(\n    address token,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n    if (amount == 0) {\n      return true;\n    }\n\n    if (isETH(token)) {\n      IWETH(WETH).withdraw(amount);\n      TransferHelper.safeTransferETH(to, amount);\n    } else {\n      TransferHelper.safeTransfer(token, to, amount);\n    }\n    return true;\n  }\n\n  function isETH(address token) internal pure returns (bool) {\n    return (token == ETH_ADDRESS);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}