{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/StakingWarmup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract StakingWarmup {\n\n    address public immutable staking;\n    address public immutable sREQT;\n\n    constructor ( address _staking, address _sREQT ) {\n        require( _staking != address(0) );\n        staking = _staking;\n        require( _sREQT != address(0) );\n        sREQT = _sREQT;\n    }\n\n    function retrieve( address _staker, uint _amount ) external {\n        require( msg.sender == staking );\n        IERC20( sREQT ).transfer( _staker, _amount );\n    }\n}"
    },
    "contracts/StakingHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract StakingHelper {\n\n    address public immutable staking;\n    address public immutable REQT;\n\n    constructor ( address _staking, address _REQT ) {\n        require( _staking != address(0) );\n        staking = _staking;\n        require( _REQT != address(0) );\n        REQT = _REQT;\n    }\n\n    function stake( uint _amount ) external {\n        IERC20( REQT ).transferFrom( msg.sender, address(this), _amount );\n        IERC20( REQT ).approve( staking, _amount );\n        IStaking( staking ).stake( _amount, msg.sender );\n        IStaking( staking ).claim( msg.sender );\n    }\n}"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IStaking {\n  function stake(uint256 _amount, address _recipient) external returns (bool);\n\n  function claim(address _recipient) external;\n\n  function unstake(uint256 _amount, address _recipient) external returns (bool);\n\n  function index() external view returns (uint256);\n}\n"
    },
    "contracts/wREQT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/ERC20.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/IStaking.sol\";\n\ncontract wREQT is ERC20 {\n  using SafeERC20 for ERC20;\n  using Address for address;\n  using SafeMath for uint256;\n\n  address public immutable staking;\n  address public immutable REQT;\n  address public immutable sREQT;\n\n  constructor(\n    address _staking,\n    address _REQT,\n    address _sREQT\n  ) ERC20(\"Wrapped sREQT\", \"wsREQT\", 18) {\n    require(_staking != address(0));\n    staking = _staking;\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_sREQT != address(0));\n    sREQT = _sREQT;\n  }\n\n  /**\n        @notice stakes REQT and wraps sREQT\n        @param _amount uint\n        @return uint\n     */\n  function wrapFromREQT(uint256 _amount) external returns (uint256) {\n    IERC20(REQT).transferFrom(msg.sender, address(this), _amount);\n\n    IERC20(REQT).approve(staking, _amount); // stake REQT for sREQT\n    IStaking(staking).stake(_amount, address(this));\n\n    uint256 value = wREQTValue(_amount);\n    _mint(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice unwrap sREQT and unstake REQT\n        @param _amount uint\n        @return uint\n     */\n  function unwrapToREQT(uint256 _amount) external returns (uint256) {\n    _burn(msg.sender, _amount);\n\n    uint256 value = sREQTValue(_amount);\n    IERC20(sREQT).approve(staking, value); // unstake sREQT for REQT\n    IStaking(staking).unstake(value, address(this));\n\n    IERC20(REQT).transfer(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice wrap sREQT\n        @param _amount uint\n        @return uint\n     */\n  function wrapFromsREQT(uint256 _amount) external returns (uint256) {\n    IERC20(sREQT).transferFrom(msg.sender, address(this), _amount);\n\n    uint256 value = wREQTValue(_amount);\n    _mint(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice unwrap sREQT\n        @param _amount uint\n        @return uint\n     */\n  function unwrapTosREQT(uint256 _amount) external returns (uint256) {\n    _burn(msg.sender, _amount);\n\n    uint256 value = sREQTValue(_amount);\n    IERC20(sREQT).transfer(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice converts wREQT amount to sREQT\n        @param _amount uint\n        @return uint\n     */\n  function sREQTValue(uint256 _amount) public view returns (uint256) {\n    return _amount.mul(IStaking(staking).index()).div(10**decimals());\n  }\n\n  /**\n        @notice converts sREQT amount to wREQT\n        @param _amount uint\n        @return uint\n     */\n  function wREQTValue(uint256 _amount) public view returns (uint256) {\n    return _amount.mul(10**decimals()).div(IStaking(staking).index());\n  }\n}\n"
    },
    "contracts/libraries/Manageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IManageable.sol\";\n\ncontract Manageable is IManageable {\n\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipPushed( address(0), _owner );\n    }\n\n    function policy() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyPolicy() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    modifier onlyManager() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyPolicy() {\n        emit OwnershipPushed( _owner, address(0) );\n        _owner = address(0);\n    }\n\n    function pushManagement( address newOwner_ ) public virtual override onlyPolicy() {\n        require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipPushed( _owner, newOwner_ );\n        _newOwner = newOwner_;\n    }\n    \n    function pullManagement() public virtual override {\n        require( msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled( _owner, _newOwner );\n        _owner = _newOwner;\n    }\n}"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./Address.sol\";\nimport \"./math/SafeMath.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\n\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(\n      value,\n      \"SafeERC20: decreased allowance below zero\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(\n      data,\n      \"SafeERC20: low-level call failed\"\n    );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n"
    },
    "contracts/libraries/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"./math/SafeMath.sol\";\n\nabstract contract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  // TODO comment actual hash value.\n  bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n    keccak256(\"ERC20Token\");\n\n  mapping(address => uint256) internal _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 internal _totalSupply;\n\n  string internal _name;\n\n  string internal _symbol;\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      _allowances[sender][msg.sender].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account_, uint256 ammount_) internal virtual {\n    require(account_ != address(0), \"ERC20: mint to the zero address\");\n    _beforeTokenTransfer(address(this), account_, ammount_);\n    _totalSupply = _totalSupply.add(ammount_);\n    _balances[account_] = _balances[account_].add(ammount_);\n    emit Transfer(address(this), account_, ammount_);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _beforeTokenTransfer(\n    address from_,\n    address to_,\n    uint256 amount_\n  ) internal virtual {}\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = add(div(a, 2), 1);\n      while (b < c) {\n        c = b;\n        b = div(add(div(a, b), b), 2);\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IManageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\ninterface IManageable {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function toBytes32(address a) internal pure returns (bytes32 b) {\n    assembly {\n      let m := mload(0x40)\n      a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n      mstore(0x40, add(m, 52))\n      b := m\n    }\n  }\n\n  function addressToString(address _address)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes32 _bytes = toBytes32(_address);\n    bytes memory HEX = \"0123456789abcdef\";\n    bytes memory _addr = new bytes(42);\n\n    _addr[0] = \"0\";\n    _addr[1] = \"x\";\n\n    for (uint256 i = 0; i < 20; i++) {\n      _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n      _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n    }\n\n    return string(_addr);\n  }\n}\n"
    },
    "contracts/wETHBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IAggragatorV3.sol\";\n\ncontract RequiemWETHBondDepository is Manageable {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n\n\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\n\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable REQT; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints REQT when receives principle\n    address public immutable DAO; // receives profit share from bond\n\n    IAggragatorV3 internal priceFeed;\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint payout; // REQT remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n        uint pricePaid; // In DAI, for front end viewing\n    }\n\n    // Info for incremental adjustments to control variable \n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _REQT,\n        address _principle,\n        address _treasury, \n        address _DAO,\n        address _feed\n    ) {\n        require( _REQT != address(0) );\n        REQT = _REQT;\n        require( _principle != address(0) );\n        principle = _principle;\n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _DAO != address(0) );\n        DAO = _DAO;\n        require( _feed != address(0) );\n        priceFeed = IAggragatorV3( _feed );\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms( \n        uint _controlVariable, \n        uint _vestingTerm,\n        uint _minimumPrice,\n        uint _maxPayout,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyPolicy() {\n        require( currentDebt() == 0, \"Debt must be 0 for initialization\" );\n        terms = Terms ({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            maxDebt: _maxDebt\n        });\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n    }\n\n\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER { VESTING, PAYOUT, DEBT }\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\n        if ( _parameter == PARAMETER.VESTING ) { // 0\n            require( _input >= 10000, \"Vesting must be longer than 36 hours\" );\n            terms.vestingTerm = _input;\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\n            terms.maxPayout = _input;\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment ( \n        bool _addition,\n        uint _increment, \n        uint _target,\n        uint _buffer \n    ) external onlyPolicy() {\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \"Increment too large\" );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\n        require( _staking != address(0) );\n        if ( _helper ) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require( _depositor != address(0), \"Invalid address\" );\n\n        decayDebt();\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\n        \n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint nativePrice = _bondPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\n        uint payout = payoutFor( value ); // payout to bonder is computed\n\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 REQT ( underflow protection )\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        /**\n            asset carries risk and is not minted against\n            asset transfered to treasury and rewards minted as payout\n         */\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\n        ITreasury( treasury ).mintRewards( address(this), payout );\n        \n        // total debt is increased\n        totalDebt = totalDebt.add( value ); \n                \n        // depositor info is stored\n        bondInfo[ _depositor ] = Bond({ \n            payout: bondInfo[ _depositor ].payout.add( payout ),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number,\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n\n        adjust(); // control variable is adjusted\n        return payout; \n    }\n\n    /** \n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */ \n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \n        Bond memory info = bondInfo[ _recipient ];\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\n\n        if ( percentVested >= 10000 ) { // if fully vested\n            delete bondInfo[ _recipient ]; // delete user info\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\n\n        } else { // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\n\n            // store updated deposit info\n            bondInfo[ _recipient ] = Bond({\n                payout: info.payout.sub( payout ),\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\n                lastBlock: block.number,\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\n            return stakeOrSend( _recipient, _stake, payout );\n        }\n    }\n\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\n        if ( !_stake ) { // if user does not want to stake\n            IERC20( REQT ).transfer( _recipient, _amount ); // send payout\n        } else { // if user wants to stake\n            if ( useHelper ) { // use if staking warmup is 0\n                IERC20( REQT ).approve( stakingHelper, _amount );\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\n            } else {\n                IERC20( REQT ).approve( staking, _amount );\n                IStaking( staking ).stake( _amount, _recipient );\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\n            uint initial = terms.controlVariable;\n            if ( adjustment.add ) {\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n                if ( terms.controlVariable >= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n                if ( terms.controlVariable <= adjustment.target ) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub( debtDecay() );\n        lastDecay = block.number;\n    }\n\n\n\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return IERC20( REQT ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\n    }\n\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns ( uint price_ ) {        \n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns ( uint price_ ) {\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\n        if ( price_ < terms.minimumPrice ) {\n            price_ = terms.minimumPrice;        \n        } else if ( terms.minimumPrice != 0 ) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice get asset price from chainlink\n     */\n    function assetPrice() public view returns (int) {\n        ( , int price, , , ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns ( uint price_ ) {\n        price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\n    }\n\n\n    /**\n     *  @notice calculate current ratio of debt to REQT supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \n        uint supply = IERC20( REQT ).totalSupply();\n        debtRatio_ = FixedPoint.fraction( \n            currentDebt().mul( 1e9 ), \n            supply\n        ).decode112with18().div( 1e18 );\n    }\n\n    /**\n     *  @notice debt ratio in same terms as reserve bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns ( uint ) {\n        return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns ( uint ) {\n        return totalDebt.sub( debtDecay() );\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns ( uint decay_ ) {\n        uint blocksSinceLast = block.number.sub( lastDecay );\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\n        if ( decay_ > totalDebt ) {\n            decay_ = totalDebt;\n        }\n    }\n\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n        Bond memory bond = bondInfo[ _depositor ];\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n        uint vesting = bond.vesting;\n\n        if ( vesting > 0 ) {\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of REQT available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n        uint percentVested = percentVestedFor( _depositor );\n        uint payout = bondInfo[ _depositor ].payout;\n\n        if ( percentVested >= 10000 ) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\n        }\n    }\n\n\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n     *  @return bool\n     */\n    function recoverLostToken( address _token ) external returns ( bool ) {\n        require( _token != REQT );\n        require( _token != principle );\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\n        return true;\n    }\n}"
    },
    "contracts/libraries/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./FullMath.sol\";\n\nlibrary FixedPoint {\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  struct uq144x112 {\n    uint256 _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint256 private constant Q112 = 0x10000000000000000000000000000;\n  uint256 private constant Q224 =\n    0x100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  function decode112with18(uq112x112 memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return uint256(self._x) / 5192296858534827;\n  }\n\n  function fraction(uint256 numerator, uint256 denominator)\n    internal\n    pure\n    returns (uq112x112 memory)\n  {\n    require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n    if (numerator == 0) return FixedPoint.uq112x112(0);\n\n    if (numerator <= type(uint144).max) {\n      uint256 result = (numerator << RESOLUTION) / denominator;\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    } else {\n      uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    }\n  }\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n    function mintRewards( address _recipient, uint _amount ) external;\n}"
    },
    "contracts/interfaces/IStakingHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IStakingHelper {\n  function stake(uint256 _amount, address _recipient) external;\n}\n"
    },
    "contracts/interfaces/IAggragatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IAggragatorV3 {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/libraries/math/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.10;\n\n// solhint-disable no-inline-assembly, reason-string, max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            // EDIT for 0.8 compatibility:\n            // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\n            uint256 twos = denominator & (~denominator + 1);\n\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}"
    },
    "contracts/RequiemCVXBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/PolicyOwned.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IBondCalculator.sol\";\n\ncontract RequiemCVXBondDepository is PolicyOwned {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principal; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principal\n  address public immutable DAO; // receives profit share from bond\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principal value. 4 decimals (1500 = 0.15)\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principal,\n    address _treasury,\n    address _DAO\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principal != address(0));\n    principal = _principal;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(currentDebt() == 0, \"Debt must be 0 for initialization\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOf(principal, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    /**\n            asset carries risk and is not minted against\n            asset transfered to treasury and rewards minted as payout\n         */\n    IERC20(principal).safeTransferFrom(msg.sender, treasury, _amount);\n    ITreasury(treasury).mintRewards(address(this), payout);\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: nativePrice\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      nativePrice\n    );\n    emit BondPriceChanged(_bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).safeTransfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e14);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).div(1e5);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).div(1e5);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principal or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principal);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/PolicyOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IPolicyOwned.sol\";\n\ncontract PolicyOwned is IPolicyOwned {\n  address internal _owner;\n  address internal _newOwner;\n\n  event OwnershipPushed(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event OwnershipPulled(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _owner = msg.sender;\n    emit OwnershipPushed(address(0), _owner);\n  }\n\n  function policy() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyPolicy() {\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceManagement() public virtual override onlyPolicy {\n    emit OwnershipPushed(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function pushManagement(address newOwner_)\n    public\n    virtual\n    override\n    onlyPolicy\n  {\n    require(newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipPushed(_owner, newOwner_);\n    _newOwner = newOwner_;\n  }\n\n  function pullManagement() public virtual override {\n    require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n    emit OwnershipPulled(_owner, _newOwner);\n    _owner = _newOwner;\n  }\n}\n"
    },
    "contracts/interfaces/IBondCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IBondCalculator {\n  function valuation(address _LP, uint256 _amount)\n    external\n    view\n    returns (uint256);\n\n  function markdown(address _LP) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPolicyOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IPolicyOwned {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/ERC20/IERC20Mintable.sol\";\nimport \"./interfaces/IREQTERC20.sol\";\nimport \"./interfaces/IBondCalculator.sol\";\n\ncontract RequiemTreasury is Manageable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  event Deposit(address indexed token, uint256 amount, uint256 value);\n  event Withdrawal(address indexed token, uint256 amount, uint256 value);\n  event CreateDebt(\n    address indexed debtor,\n    address indexed token,\n    uint256 amount,\n    uint256 value\n  );\n  event RepayDebt(\n    address indexed debtor,\n    address indexed token,\n    uint256 amount,\n    uint256 value\n  );\n  event ReservesManaged(address indexed token, uint256 amount);\n  event ReservesUpdated(uint256 indexed totalReserves);\n  event ReservesAudited(uint256 indexed totalReserves);\n  event RewardsMinted(\n    address indexed caller,\n    address indexed recipient,\n    uint256 amount\n  );\n  event ChangeQueued(MANAGING indexed managing, address queued);\n  event ChangeActivated(\n    MANAGING indexed managing,\n    address activated,\n    bool result\n  );\n\n  enum MANAGING {\n    RESERVEDEPOSITOR,\n    RESERVESPENDER,\n    RESERVETOKEN,\n    RESERVEMANAGER,\n    LIQUIDITYDEPOSITOR,\n    LIQUIDITYTOKEN,\n    LIQUIDITYMANAGER,\n    DEBTOR,\n    REWARDMANAGER,\n    SREQT\n  }\n\n  address public immutable REQT;\n  uint256 public immutable blocksNeededForQueue;\n\n  address[] public reserveTokens; // Push only, beware false-positives.\n  mapping(address => bool) public isReserveToken;\n  mapping(address => uint256) public reserveTokenQueue; // Delays changes to mapping.\n\n  address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isReserveDepositor;\n  mapping(address => uint256) public reserveDepositorQueue; // Delays changes to mapping.\n\n  address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isReserveSpender;\n  mapping(address => uint256) public reserveSpenderQueue; // Delays changes to mapping.\n\n  address[] public liquidityTokens; // Push only, beware false-positives.\n  mapping(address => bool) public isLiquidityToken;\n  mapping(address => uint256) public LiquidityTokenQueue; // Delays changes to mapping.\n\n  address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isLiquidityDepositor;\n  mapping(address => uint256) public LiquidityDepositorQueue; // Delays changes to mapping.\n\n  mapping(address => address) public bondCalculator; // bond calculator for liquidity token\n\n  address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isReserveManager;\n  mapping(address => uint256) public ReserveManagerQueue; // Delays changes to mapping.\n\n  address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isLiquidityManager;\n  mapping(address => uint256) public LiquidityManagerQueue; // Delays changes to mapping.\n\n  address[] public debtors; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isDebtor;\n  mapping(address => uint256) public debtorQueue; // Delays changes to mapping.\n  mapping(address => uint256) public debtorBalance;\n\n  address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isRewardManager;\n  mapping(address => uint256) public rewardManagerQueue; // Delays changes to mapping.\n\n  address public sREQT;\n  uint256 public sREQTQueue; // Delays change to sREQT address\n\n  uint256 public totalReserves; // Risk-free value of all assets\n  uint256 public totalDebt;\n\n  constructor(\n    address _REQT,\n    address _DAI,\n    address _Frax,\n    address _REQTDAI,\n    uint256 _blocksNeededForQueue\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n\n    isReserveToken[_DAI] = true;\n    reserveTokens.push(_DAI);\n\n    isReserveToken[_Frax] = true;\n    reserveTokens.push(_Frax);\n\n    isLiquidityToken[_REQTDAI] = true;\n    liquidityTokens.push(_REQTDAI);\n\n    blocksNeededForQueue = _blocksNeededForQueue;\n  }\n\n  /**\n        @notice allow approved address to deposit an asset for REQT\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (uint256 send_) {\n    require(isReserveToken[_token] || isLiquidityToken[_token], \"Not accepted\");\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n    if (isReserveToken[_token]) {\n      require(isReserveDepositor[msg.sender], \"Not approved\");\n    } else {\n      require(isLiquidityDepositor[msg.sender], \"Not approved\");\n    }\n\n    uint256 value = valueOf(_token, _amount);\n    // mint REQT needed and store amount of rewards for distribution\n    send_ = value.sub(_profit);\n    IERC20Mintable(REQT).mint(msg.sender, send_);\n\n    totalReserves = totalReserves.add(value);\n    emit ReservesUpdated(totalReserves);\n\n    emit Deposit(_token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to burn REQT for reserves\n        @param _amount uint\n        @param _token address\n     */\n  function withdraw(uint256 _amount, address _token) external {\n    require(isReserveToken[_token], \"Not accepted\"); // Only reserves can be used for redemptions\n    require(isReserveSpender[msg.sender] == true, \"Not approved\");\n\n    uint256 value = valueOf(_token, _amount);\n    IREQTERC20(REQT).burnFrom(msg.sender, value);\n\n    totalReserves = totalReserves.sub(value);\n    emit ReservesUpdated(totalReserves);\n\n    IERC20(_token).safeTransfer(msg.sender, _amount);\n\n    emit Withdrawal(_token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n  function incurDebt(uint256 _amount, address _token) external {\n    require(isDebtor[msg.sender], \"Not approved\");\n    require(isReserveToken[_token], \"Not accepted\");\n\n    uint256 value = valueOf(_token, _amount);\n\n    uint256 maximumDebt = IERC20(sREQT).balanceOf(msg.sender); // Can only borrow against sREQT held\n    uint256 availableDebt = maximumDebt.sub(debtorBalance[msg.sender]);\n    require(value <= availableDebt, \"Exceeds debt limit\");\n\n    debtorBalance[msg.sender] = debtorBalance[msg.sender].add(value);\n    totalDebt = totalDebt.add(value);\n\n    totalReserves = totalReserves.sub(value);\n    emit ReservesUpdated(totalReserves);\n\n    IERC20(_token).transfer(msg.sender, _amount);\n\n    emit CreateDebt(msg.sender, _token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n  function repayDebtWithReserve(uint256 _amount, address _token) external {\n    require(isDebtor[msg.sender], \"Not approved\");\n    require(isReserveToken[_token], \"Not accepted\");\n\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 value = valueOf(_token, _amount);\n    debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(value);\n    totalDebt = totalDebt.sub(value);\n\n    totalReserves = totalReserves.add(value);\n    emit ReservesUpdated(totalReserves);\n\n    emit RepayDebt(msg.sender, _token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to repay borrowed reserves with REQT\n        @param _amount uint\n     */\n  function repayDebtWithREQT(uint256 _amount) external {\n    require(isDebtor[msg.sender], \"Not approved\");\n\n    IREQTERC20(REQT).burnFrom(msg.sender, _amount);\n\n    debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(_amount);\n    totalDebt = totalDebt.sub(_amount);\n\n    emit RepayDebt(msg.sender, REQT, _amount, _amount);\n  }\n\n  /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n  function manage(address _token, uint256 _amount) external {\n    if (isLiquidityToken[_token]) {\n      require(isLiquidityManager[msg.sender], \"Not approved\");\n    } else {\n      require(isReserveManager[msg.sender], \"Not approved\");\n    }\n\n    uint256 value = valueOf(_token, _amount);\n    require(value <= excessReserves(), \"Insufficient reserves\");\n\n    totalReserves = totalReserves.sub(value);\n    emit ReservesUpdated(totalReserves);\n\n    IERC20(_token).safeTransfer(msg.sender, _amount);\n\n    emit ReservesManaged(_token, _amount);\n  }\n\n  /**\n        @notice send epoch reward to staking contract\n     */\n  function mintRewards(address _recipient, uint256 _amount) external {\n    require(isRewardManager[msg.sender], \"Not approved\");\n    require(_amount <= excessReserves(), \"Insufficient reserves\");\n\n    IERC20Mintable(REQT).mint(_recipient, _amount);\n\n    emit RewardsMinted(msg.sender, _recipient, _amount);\n  }\n\n  /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n  function excessReserves() public view returns (uint256) {\n    return totalReserves.sub(IERC20(REQT).totalSupply().sub(totalDebt));\n  }\n\n  /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n  function auditReserves() external onlyManager {\n    uint256 reserves;\n    for (uint256 i = 0; i < reserveTokens.length; i++) {\n      reserves = reserves.add(\n        valueOf(\n          reserveTokens[i],\n          IERC20(reserveTokens[i]).balanceOf(address(this))\n        )\n      );\n    }\n    for (uint256 i = 0; i < liquidityTokens.length; i++) {\n      reserves = reserves.add(\n        valueOf(\n          liquidityTokens[i],\n          IERC20(liquidityTokens[i]).balanceOf(address(this))\n        )\n      );\n    }\n    totalReserves = reserves;\n    emit ReservesUpdated(reserves);\n    emit ReservesAudited(reserves);\n  }\n\n  /**\n        @notice returns REQT valuation of asset\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n  function valueOf(address _token, uint256 _amount)\n    public\n    view\n    returns (uint256 value_)\n  {\n    if (isReserveToken[_token]) {\n      // convert amount to match REQT decimals\n      value_ = _amount.mul(10**IERC20(REQT).decimals()).div(\n        10**IERC20(_token).decimals()\n      );\n    } else if (isLiquidityToken[_token]) {\n      value_ = IBondCalculator(bondCalculator[_token]).valuation(\n        _token,\n        _amount\n      );\n    }\n  }\n\n  /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n  function queue(MANAGING _managing, address _address)\n    external\n    onlyManager\n    returns (bool)\n  {\n    require(_address != address(0));\n    if (_managing == MANAGING.RESERVEDEPOSITOR) {\n      // 0\n      reserveDepositorQueue[_address] = block.number.add(blocksNeededForQueue);\n    } else if (_managing == MANAGING.RESERVESPENDER) {\n      // 1\n      reserveSpenderQueue[_address] = block.number.add(blocksNeededForQueue);\n    } else if (_managing == MANAGING.RESERVETOKEN) {\n      // 2\n      reserveTokenQueue[_address] = block.number.add(blocksNeededForQueue);\n    } else if (_managing == MANAGING.RESERVEMANAGER) {\n      // 3\n      ReserveManagerQueue[_address] = block.number.add(\n        blocksNeededForQueue.mul(2)\n      );\n    } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n      // 4\n      LiquidityDepositorQueue[_address] = block.number.add(\n        blocksNeededForQueue\n      );\n    } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n      // 5\n      LiquidityTokenQueue[_address] = block.number.add(blocksNeededForQueue);\n    } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n      // 6\n      LiquidityManagerQueue[_address] = block.number.add(\n        blocksNeededForQueue.mul(2)\n      );\n    } else if (_managing == MANAGING.DEBTOR) {\n      // 7\n      debtorQueue[_address] = block.number.add(blocksNeededForQueue);\n    } else if (_managing == MANAGING.REWARDMANAGER) {\n      // 8\n      rewardManagerQueue[_address] = block.number.add(blocksNeededForQueue);\n    } else if (_managing == MANAGING.SREQT) {\n      // 9\n      sREQTQueue = block.number.add(blocksNeededForQueue);\n    } else return false;\n\n    emit ChangeQueued(_managing, _address);\n    return true;\n  }\n\n  /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @param _calculator address\n        @return bool\n     */\n  function toggle(\n    MANAGING _managing,\n    address _address,\n    address _calculator\n  ) external onlyManager returns (bool) {\n    require(_address != address(0));\n    bool result;\n    if (_managing == MANAGING.RESERVEDEPOSITOR) {\n      // 0\n      if (requirements(reserveDepositorQueue, isReserveDepositor, _address)) {\n        reserveDepositorQueue[_address] = 0;\n        if (!listContains(reserveDepositors, _address)) {\n          reserveDepositors.push(_address);\n        }\n      }\n      result = !isReserveDepositor[_address];\n      isReserveDepositor[_address] = result;\n    } else if (_managing == MANAGING.RESERVESPENDER) {\n      // 1\n      if (requirements(reserveSpenderQueue, isReserveSpender, _address)) {\n        reserveSpenderQueue[_address] = 0;\n        if (!listContains(reserveSpenders, _address)) {\n          reserveSpenders.push(_address);\n        }\n      }\n      result = !isReserveSpender[_address];\n      isReserveSpender[_address] = result;\n    } else if (_managing == MANAGING.RESERVETOKEN) {\n      // 2\n      if (requirements(reserveTokenQueue, isReserveToken, _address)) {\n        reserveTokenQueue[_address] = 0;\n        if (!listContains(reserveTokens, _address)) {\n          reserveTokens.push(_address);\n        }\n      }\n      result = !isReserveToken[_address];\n      isReserveToken[_address] = result;\n    } else if (_managing == MANAGING.RESERVEMANAGER) {\n      // 3\n      if (requirements(ReserveManagerQueue, isReserveManager, _address)) {\n        reserveManagers.push(_address);\n        ReserveManagerQueue[_address] = 0;\n        if (!listContains(reserveManagers, _address)) {\n          reserveManagers.push(_address);\n        }\n      }\n      result = !isReserveManager[_address];\n      isReserveManager[_address] = result;\n    } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n      // 4\n      if (\n        requirements(LiquidityDepositorQueue, isLiquidityDepositor, _address)\n      ) {\n        liquidityDepositors.push(_address);\n        LiquidityDepositorQueue[_address] = 0;\n        if (!listContains(liquidityDepositors, _address)) {\n          liquidityDepositors.push(_address);\n        }\n      }\n      result = !isLiquidityDepositor[_address];\n      isLiquidityDepositor[_address] = result;\n    } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n      // 5\n      if (requirements(LiquidityTokenQueue, isLiquidityToken, _address)) {\n        LiquidityTokenQueue[_address] = 0;\n        if (!listContains(liquidityTokens, _address)) {\n          liquidityTokens.push(_address);\n        }\n      }\n      result = !isLiquidityToken[_address];\n      isLiquidityToken[_address] = result;\n      bondCalculator[_address] = _calculator;\n    } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n      // 6\n      if (requirements(LiquidityManagerQueue, isLiquidityManager, _address)) {\n        LiquidityManagerQueue[_address] = 0;\n        if (!listContains(liquidityManagers, _address)) {\n          liquidityManagers.push(_address);\n        }\n      }\n      result = !isLiquidityManager[_address];\n      isLiquidityManager[_address] = result;\n    } else if (_managing == MANAGING.DEBTOR) {\n      // 7\n      if (requirements(debtorQueue, isDebtor, _address)) {\n        debtorQueue[_address] = 0;\n        if (!listContains(debtors, _address)) {\n          debtors.push(_address);\n        }\n      }\n      result = !isDebtor[_address];\n      isDebtor[_address] = result;\n    } else if (_managing == MANAGING.REWARDMANAGER) {\n      // 8\n      if (requirements(rewardManagerQueue, isRewardManager, _address)) {\n        rewardManagerQueue[_address] = 0;\n        if (!listContains(rewardManagers, _address)) {\n          rewardManagers.push(_address);\n        }\n      }\n      result = !isRewardManager[_address];\n      isRewardManager[_address] = result;\n    } else if (_managing == MANAGING.SREQT) {\n      // 9\n      sREQTQueue = 0;\n      sREQT = _address;\n      result = true;\n    } else return false;\n\n    emit ChangeActivated(_managing, _address, result);\n    return true;\n  }\n\n  /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n  function requirements(\n    mapping(address => uint256) storage queue_,\n    mapping(address => bool) storage status_,\n    address _address\n  ) internal view returns (bool) {\n    if (!status_[_address]) {\n      require(queue_[_address] != 0, \"Must queue\");\n      require(queue_[_address] <= block.number, \"Queue not expired\");\n      return true;\n    }\n    return false;\n  }\n\n  /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n  function listContains(address[] storage _list, address _token)\n    internal\n    view\n    returns (bool)\n  {\n    for (uint256 i = 0; i < _list.length; i++) {\n      if (_list[i] == _token) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20Mintable {\n  function mint(uint256 amount_) external;\n\n  function mint(address account_, uint256 ammount_) external;\n}\n"
    },
    "contracts/interfaces/IREQTERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IREQTERC20 {\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/StakingDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/Policy.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\ncontract Distributor is Policy {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n    \n    \n    \n    /* ====== VARIABLES ====== */\n\n    address public immutable OHM;\n    address public immutable treasury;\n    \n    uint public immutable epochLength;\n    uint public nextEpochBlock;\n    \n    mapping( uint => Adjust ) public adjustments;\n    \n    \n    /* ====== STRUCTS ====== */\n        \n    struct Info {\n        uint rate; // in ten-thousandths ( 5000 = 0.5% )\n        address recipient;\n    }\n    Info[] public info;\n    \n    struct Adjust {\n        bool add;\n        uint rate;\n        uint target;\n    }\n    \n    \n    \n    /* ====== CONSTRUCTOR ====== */\n\n    constructor( address _treasury, address _ohm, uint _epochLength, uint _nextEpochBlock ) {        \n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _ohm != address(0) );\n        OHM = _ohm;\n        epochLength = _epochLength;\n        nextEpochBlock = _nextEpochBlock;\n    }\n    \n    \n    \n    /* ====== PUBLIC FUNCTIONS ====== */\n    \n    /**\n        @notice send epoch reward to staking contract\n     */\n    function distribute() external returns ( bool ) {\n        if ( nextEpochBlock <= block.number ) {\n            nextEpochBlock = nextEpochBlock.add( epochLength ); // set next epoch block\n            \n            // distribute rewards to each recipient\n            for ( uint i = 0; i < info.length; i++ ) {\n                if ( info[ i ].rate > 0 ) {\n                    ITreasury( treasury ).mintRewards( // mint and send from treasury\n                        info[ i ].recipient, \n                        nextRewardAt( info[ i ].rate ) \n                    );\n                    adjust( i ); // check for adjustment\n                }\n            }\n            return true;\n        } else { \n            return false; \n        }\n    }\n    \n    \n    \n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /**\n        @notice increment reward rate for collector\n     */\n    function adjust( uint _index ) internal {\n        Adjust memory adjustment = adjustments[ _index ];\n        if ( adjustment.rate != 0 ) {\n            if ( adjustment.add ) { // if rate should increase\n                info[ _index ].rate = info[ _index ].rate.add( adjustment.rate ); // raise rate\n                if ( info[ _index ].rate >= adjustment.target ) { // if target met\n                    adjustments[ _index ].rate = 0; // turn off adjustment\n                }\n            } else { // if rate should decrease\n                info[ _index ].rate = info[ _index ].rate.sub( adjustment.rate ); // lower rate\n                if ( info[ _index ].rate <= adjustment.target ) { // if target met\n                    adjustments[ _index ].rate = 0; // turn off adjustment\n                }\n            }\n        }\n    }\n    \n    \n    \n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt( uint _rate ) public view returns ( uint ) {\n        return IERC20( OHM ).totalSupply().mul( _rate ).div( 1000000 );\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint\n     */\n    function nextRewardFor( address _recipient ) public view returns ( uint ) {\n        uint reward;\n        for ( uint i = 0; i < info.length; i++ ) {\n            if ( info[ i ].recipient == _recipient ) {\n                reward = nextRewardAt( info[ i ].rate );\n            }\n        }\n        return reward;\n    }\n    \n    \n    \n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n        @notice adds recipient for distributions\n        @param _recipient address\n        @param _rewardRate uint\n     */\n    function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {\n        require( _recipient != address(0) );\n        info.push( Info({\n            recipient: _recipient,\n            rate: _rewardRate\n        }));\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n        @param _recipient address\n     */\n    function removeRecipient( uint _index, address _recipient ) external onlyPolicy() {\n        require( _recipient == info[ _index ].recipient );\n        info[ _index ].recipient = address(0);\n        info[ _index ].rate = 0;\n    }\n\n    /**\n        @notice set adjustment info for a collector's reward rate\n        @param _index uint\n        @param _add bool\n        @param _rate uint\n        @param _target uint\n     */\n    function setAdjustment( uint _index, bool _add, uint _rate, uint _target ) external onlyPolicy() {\n        adjustments[ _index ] = Adjust({\n            add: _add,\n            rate: _rate,\n            target: _target\n        });\n    }\n}"
    },
    "contracts/libraries/Policy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../interfaces/IPolicy.sol\";\n\ncontract Policy is IPolicy {\n  address internal _policy;\n  address internal _newPolicy;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _policy = msg.sender;\n    emit OwnershipTransferred(address(0), _policy);\n  }\n\n  function policy() public view override returns (address) {\n    return _policy;\n  }\n\n  modifier onlyPolicy() {\n    require(_policy == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renouncePolicy() public virtual override onlyPolicy {\n    emit OwnershipTransferred(_policy, address(0));\n    _policy = address(0);\n  }\n\n  function pushPolicy(address newPolicy_) public virtual override onlyPolicy {\n    require(newPolicy_ != address(0), \"Ownable: new owner is the zero address\");\n    _newPolicy = newPolicy_;\n  }\n\n  function pullPolicy() public virtual override {\n    require(msg.sender == _newPolicy);\n    emit OwnershipTransferred(_policy, _newPolicy);\n    _policy = _newPolicy;\n  }\n}\n"
    },
    "contracts/interfaces/IPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IPolicy {\n\n    function policy() external view returns (address);\n\n    function renouncePolicy() external;\n  \n    function pushPolicy( address newPolicy_ ) external;\n\n    function pullPolicy() external;\n}\n"
    },
    "contracts/RequiemStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/Manageable.sol\";\nimport \"./interfaces/IWarmup.sol\";\nimport \"./interfaces/IDistributor.sol\";\nimport \"./interfaces/IsREQT.sol\";\n\ncontract RequiemStaking is Manageable {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable REQT;\n    address public immutable sREQT;\n\n    struct Epoch {\n        uint length;\n        uint number;\n        uint endBlock;\n        uint distribute;\n    }\n    Epoch public epoch;\n\n    address public distributor;\n    \n    address public locker;\n    uint public totalBonus;\n    \n    address public warmupContract;\n    uint public warmupPeriod;\n    \n    constructor ( \n        address _REQT, \n        address _sREQT, \n        uint _epochLength,\n        uint _firstEpochNumber,\n        uint _firstEpochBlock\n    ) {\n        require( _REQT != address(0) );\n        REQT = _REQT;\n        require( _sREQT != address(0) );\n        sREQT = _sREQT;\n        \n        epoch = Epoch({\n            length: _epochLength,\n            number: _firstEpochNumber,\n            endBlock: _firstEpochBlock,\n            distribute: 0\n        });\n    }\n\n    struct Claim {\n        uint deposit;\n        uint gons;\n        uint expiry;\n        bool lock; // prevents malicious delays\n    }\n    mapping( address => Claim ) public warmupInfo;\n\n    /**\n        @notice stake REQT to enter warmup\n        @param _amount uint\n        @return bool\n     */\n    function stake( uint _amount, address _recipient ) external returns ( bool ) {\n        rebase();\n        \n        IERC20( REQT ).safeTransferFrom( msg.sender, address(this), _amount );\n\n        Claim memory info = warmupInfo[ _recipient ];\n        require( !info.lock, \"Deposits for account are locked\" );\n\n        warmupInfo[ _recipient ] = Claim ({\n            deposit: info.deposit.add( _amount ),\n            gons: info.gons.add( IsREQT( sREQT ).gonsForBalance( _amount ) ),\n            expiry: epoch.number.add( warmupPeriod ),\n            lock: false\n        });\n        \n        IERC20( sREQT ).safeTransfer( warmupContract, _amount );\n        return true;\n    }\n\n    /**\n        @notice retrieve sREQT from warmup\n        @param _recipient address\n     */\n    function claim ( address _recipient ) public {\n        Claim memory info = warmupInfo[ _recipient ];\n        if ( epoch.number >= info.expiry && info.expiry != 0 ) {\n            delete warmupInfo[ _recipient ];\n            IWarmup( warmupContract ).retrieve( _recipient, IsREQT( sREQT ).balanceForGons( info.gons ) );\n        }\n    }\n\n    /**\n        @notice forfeit sREQT in warmup and retrieve REQT\n     */\n    function forfeit() external {\n        Claim memory info = warmupInfo[ msg.sender ];\n        delete warmupInfo[ msg.sender ];\n\n        IWarmup( warmupContract ).retrieve( address(this), IsREQT( sREQT ).balanceForGons( info.gons ) );\n        IERC20( REQT ).safeTransfer( msg.sender, info.deposit );\n    }\n\n    /**\n        @notice prevent new deposits to address (protection from malicious activity)\n     */\n    function toggleDepositLock() external {\n        warmupInfo[ msg.sender ].lock = !warmupInfo[ msg.sender ].lock;\n    }\n\n    /**\n        @notice redeem sREQT for REQT\n        @param _amount uint\n        @param _trigger bool\n     */\n    function unstake( uint _amount, bool _trigger ) external {\n        if ( _trigger ) {\n            rebase();\n        }\n        IERC20( sREQT ).safeTransferFrom( msg.sender, address(this), _amount );\n        IERC20( REQT ).safeTransfer( msg.sender, _amount );\n    }\n\n    /**\n        @notice returns the sREQT index, which tracks rebase growth\n        @return uint\n     */\n    function index() public view returns ( uint ) {\n        return IsREQT( sREQT ).index();\n    }\n\n    /**\n        @notice trigger rebase if epoch over\n     */\n    function rebase() public {\n        if( epoch.endBlock <= block.number ) {\n\n            IsREQT( sREQT ).rebase( epoch.distribute, epoch.number );\n\n            epoch.endBlock = epoch.endBlock.add( epoch.length );\n            epoch.number++;\n            \n            if ( distributor != address(0) ) {\n                IDistributor( distributor ).distribute();\n            }\n\n            uint balance = contractBalance();\n            uint staked = IsREQT( sREQT ).circulatingSupply();\n\n            if( balance <= staked ) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance.sub( staked );\n            }\n        }\n    }\n\n    /**\n        @notice returns contract REQT holdings, including bonuses provided\n        @return uint\n     */\n    function contractBalance() public view returns ( uint ) {\n        return IERC20( REQT ).balanceOf( address(this) ).add( totalBonus );\n    }\n\n    /**\n        @notice provide bonus to locked staking contract\n        @param _amount uint\n     */\n    function giveLockBonus( uint _amount ) external {\n        require( msg.sender == locker );\n        totalBonus = totalBonus.add( _amount );\n        IERC20( sREQT ).safeTransfer( locker, _amount );\n    }\n\n    /**\n        @notice reclaim bonus from locked staking contract\n        @param _amount uint\n     */\n    function returnLockBonus( uint _amount ) external {\n        require( msg.sender == locker );\n        totalBonus = totalBonus.sub( _amount );\n        IERC20( sREQT ).safeTransferFrom( locker, address(this), _amount );\n    }\n\n    enum CONTRACTS { DISTRIBUTOR, WARMUP, LOCKER }\n\n    /**\n        @notice sets the contract address for LP staking\n        @param _contract address\n     */\n    function setContract( CONTRACTS _contract, address _address ) external onlyManager() {\n        if( _contract == CONTRACTS.DISTRIBUTOR ) { // 0\n            distributor = _address;\n        } else if ( _contract == CONTRACTS.WARMUP ) { // 1\n            require( warmupContract == address( 0 ), \"Warmup cannot be set more than once\" );\n            warmupContract = _address;\n        } else if ( _contract == CONTRACTS.LOCKER ) { // 2\n            require( locker == address(0), \"Locker cannot be set more than once\" );\n            locker = _address;\n        }\n    }\n    \n    /**\n     * @notice set warmup period for new stakers\n     * @param _warmupPeriod uint\n     */\n    function setWarmup( uint _warmupPeriod ) external onlyManager() {\n        warmupPeriod = _warmupPeriod;\n    }\n}"
    },
    "contracts/interfaces/IWarmup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IWarmup {\n    function retrieve( address staker_, uint amount_ ) external;\n}"
    },
    "contracts/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IDistributor {\n    function distribute() external returns ( bool );\n}"
    },
    "contracts/interfaces/IsREQT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IsREQT {\n    function rebase( uint256 reqtProfit_, uint epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function gonsForBalance( uint amount ) external view returns ( uint );\n\n    function balanceForGons( uint gons ) external view returns ( uint );\n    \n    function index() external view returns ( uint );\n}\n"
    },
    "contracts/sRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./libraries/Manageable.sol\";\n\ncontract sRequiem is ERC20Permit, Manageable {\n  using SafeMath for uint256;\n\n  modifier onlyStakingContract() {\n    require(msg.sender == stakingContract);\n    _;\n  }\n\n  address public stakingContract;\n  address public initializer;\n\n  event LogSupply(\n    uint256 indexed epoch,\n    uint256 timestamp,\n    uint256 totalSupply\n  );\n  event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n  event LogStakingContractUpdated(address stakingContract);\n\n  struct Rebase {\n    uint256 epoch;\n    uint256 rebase; // 18 decimals\n    uint256 totalStakedBefore;\n    uint256 totalStakedAfter;\n    uint256 amountRebased;\n    uint256 index;\n    uint256 blockNumberOccured;\n  }\n  Rebase[] public rebases;\n\n  uint256 public INDEX;\n\n  uint256 private constant MAX_UINT256 = ~uint256(0);\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**9;\n\n  // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n  // Use the highest value that fits in a uint256 for max granularity.\n  uint256 private constant TOTAL_GONS =\n    MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n  // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\n  uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n\n  uint256 private _gonsPerFragment;\n  mapping(address => uint256) private _gonBalances;\n\n  mapping(address => mapping(address => uint256)) private _allowedValue;\n\n  constructor() ERC20(\"Staked Olympus\", \"sOHM\", 9) ERC20Permit() {\n    initializer = msg.sender;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n  }\n\n  function initialize(address stakingContract_) external returns (bool) {\n    require(msg.sender == initializer);\n    require(stakingContract_ != address(0));\n    stakingContract = stakingContract_;\n    _gonBalances[stakingContract] = TOTAL_GONS;\n\n    emit Transfer(address(0x0), stakingContract, _totalSupply);\n    emit LogStakingContractUpdated(stakingContract_);\n\n    initializer = address(0);\n    return true;\n  }\n\n  function setIndex(uint256 _INDEX) external onlyManager returns (bool) {\n    require(INDEX == 0);\n    INDEX = gonsForBalance(_INDEX);\n    return true;\n  }\n\n  /**\n        @notice increases sOHM supply to increase staking balances relative to profit_\n        @param profit_ uint256\n        @return uint256\n     */\n  function rebase(uint256 profit_, uint256 epoch_)\n    public\n    onlyStakingContract\n    returns (uint256)\n  {\n    uint256 rebaseAmount;\n    uint256 circulatingSupply_ = circulatingSupply();\n\n    if (profit_ == 0) {\n      emit LogSupply(epoch_, block.timestamp, _totalSupply);\n      emit LogRebase(epoch_, 0, index());\n      return _totalSupply;\n    } else if (circulatingSupply_ > 0) {\n      rebaseAmount = profit_.mul(_totalSupply).div(circulatingSupply_);\n    } else {\n      rebaseAmount = profit_;\n    }\n\n    _totalSupply = _totalSupply.add(rebaseAmount);\n\n    if (_totalSupply > MAX_SUPPLY) {\n      _totalSupply = MAX_SUPPLY;\n    }\n\n    _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n    _storeRebase(circulatingSupply_, profit_, epoch_);\n\n    return _totalSupply;\n  }\n\n  /**\n        @notice emits event with data about rebase\n        @param previousCirculating_ uint\n        @param profit_ uint\n        @param epoch_ uint\n        @return bool\n     */\n  function _storeRebase(\n    uint256 previousCirculating_,\n    uint256 profit_,\n    uint256 epoch_\n  ) internal returns (bool) {\n    uint256 rebasePercent = profit_.mul(1e18).div(previousCirculating_);\n\n    rebases.push(\n      Rebase({\n        epoch: epoch_,\n        rebase: rebasePercent, // 18 decimals\n        totalStakedBefore: previousCirculating_,\n        totalStakedAfter: circulatingSupply(),\n        amountRebased: profit_,\n        index: index(),\n        blockNumberOccured: block.number\n      })\n    );\n\n    emit LogSupply(epoch_, block.timestamp, _totalSupply);\n    emit LogRebase(epoch_, rebasePercent, index());\n\n    return true;\n  }\n\n  function balanceOf(address who) public view override returns (uint256) {\n    return _gonBalances[who].div(_gonsPerFragment);\n  }\n\n  function gonsForBalance(uint256 amount) public view returns (uint256) {\n    return amount.mul(_gonsPerFragment);\n  }\n\n  function balanceForGons(uint256 gons) public view returns (uint256) {\n    return gons.div(_gonsPerFragment);\n  }\n\n  // Staking contract holds excess sOHM\n  function circulatingSupply() public view returns (uint256) {\n    return _totalSupply.sub(balanceOf(stakingContract));\n  }\n\n  function index() public view returns (uint256) {\n    return balanceForGons(INDEX);\n  }\n\n  function transfer(address to, uint256 value) public override returns (bool) {\n    uint256 gonValue = value.mul(_gonsPerFragment);\n    _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\n    _gonBalances[to] = _gonBalances[to].add(gonValue);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function allowance(address owner_, address spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _allowedValue[owner_][spender];\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) public override returns (bool) {\n    _allowedValue[from][msg.sender] = _allowedValue[from][msg.sender].sub(\n      value\n    );\n    emit Approval(from, msg.sender, _allowedValue[from][msg.sender]);\n\n    uint256 gonValue = gonsForBalance(value);\n    _gonBalances[from] = _gonBalances[from].sub(gonValue);\n    _gonBalances[to] = _gonBalances[to].add(gonValue);\n    emit Transfer(from, to, value);\n\n    return true;\n  }\n\n  function approve(address spender, uint256 value)\n    public\n    override\n    returns (bool)\n  {\n    _allowedValue[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  // What gets called in a permit\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  ) internal virtual override {\n    _allowedValue[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    override\n    returns (bool)\n  {\n    _allowedValue[msg.sender][spender] = _allowedValue[msg.sender][spender].add(\n      addedValue\n    );\n    emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    override\n    returns (bool)\n  {\n    uint256 oldValue = _allowedValue[msg.sender][spender];\n    if (subtractedValue >= oldValue) {\n      _allowedValue[msg.sender][spender] = 0;\n    } else {\n      _allowedValue[msg.sender][spender] = oldValue.sub(subtractedValue);\n    }\n    emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/IERC2612Permit.sol\";\nimport \"./math/Counters.sol\";\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n  using Counters for Counters.Counter;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant PERMIT_TYPEHASH =\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor() {\n    uint256 chainID;\n    assembly {\n      chainID := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(name())),\n        keccak256(bytes(\"1\")), // Version\n        chainID,\n        address(this)\n      )\n    );\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n    bytes32 hashStruct = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        amount,\n        _nonces[owner].current(),\n        deadline\n      )\n    );\n\n    bytes32 _hash = keccak256(\n      abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n    );\n\n    address signer = ecrecover(_hash, v, r, s);\n    require(\n      signer != address(0) && signer == owner,\n      \"ZeroSwapPermit: Invalid signature\"\n    );\n\n    _nonces[owner].increment();\n    _approve(owner, spender, amount);\n  }\n\n  function nonces(address owner) public view override returns (uint256) {\n    return _nonces[owner].current();\n  }\n}\n"
    },
    "contracts/interfaces/IERC2612Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC2612Permit {\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n}"
    },
    "contracts/libraries/math/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./SafeMath.sol\";\n\nlibrary Counters {\n  using SafeMath for uint256;\n\n  struct Counter {\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    counter._value += 1;\n  }\n\n  function decrement(Counter storage counter) internal {\n    counter._value = counter._value.sub(1);\n  }\n}\n"
    },
    "contracts/RequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./libraries/VaultOwned.sol\";\n\ncontract RequiemERC20Token is ERC20Permit, VaultOwned {\n\n    using SafeMath for uint256;\n\n    constructor() ERC20(\"Requiem Token\", \"REQT\", 18) {\n    }\n\n    function mint(address account_, uint256 amount_) external onlyVault() {\n        _mint(account_, amount_);\n    }\n\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n     \n    function burnFrom(address account_, uint256 amount_) public virtual {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) public virtual {\n        uint256 decreasedAllowance_ =\n            allowance(account_, msg.sender).sub(\n                amount_,\n                \"ERC20: burn amount exceeds allowance\"\n            );\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}"
    },
    "contracts/libraries/VaultOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./Ownable.sol\";\n\ncontract VaultOwned is Ownable {\n    \n  address internal _vault;\n\n  function setVault( address vault_ ) external onlyOwner() returns ( bool ) {\n    _vault = vault_;\n\n    return true;\n  }\n\n  function vault() public view returns (address) {\n    return _vault;\n  }\n\n  modifier onlyVault() {\n    require( _vault == msg.sender, \"VaultOwned: caller is not the Vault\" );\n    _;\n  }\n\n}"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../interfaces/IOwnable.sol\";\n\ncontract Ownable is IOwnable {\n    \n  address internal _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () {\n    _owner = msg.sender;\n    emit OwnershipTransferred( address(0), _owner );\n  }\n\n  function owner() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n    _;\n  }\n\n  function renounceOwnership() public virtual override onlyOwner() {\n    emit OwnershipTransferred( _owner, address(0) );\n    _owner = address(0);\n  }\n\n  function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n    require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred( _owner, newOwner_ );\n    _owner = newOwner_;\n  }\n}"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n  \n  function transferOwnership( address newOwner_ ) external;\n}"
    },
    "contracts/RequiemBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IBondCalculator.sol\";\n\ncontract RequiemBondDepository is Manageable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n  address public immutable bondCalculator; // calculates value of LP tokens\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _bondCalculator\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    // bondCalculator should be address(0) if not LP bond\n    bondCalculator = _bondCalculator;\n    isLiquidityBond = (_bondCalculator != address(0));\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _fee uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _fee,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      fee: _fee,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.FEE) {\n      // 2\n      require(_input <= 10000, \"DAO fee cannot exceed payout\");\n      terms.fee = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOf(principle, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    // profits are calculated\n    uint256 fee = payout.mul(terms.fee).div(10000);\n    uint256 profit = value.sub(payout).sub(fee);\n\n    /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) REQT\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(principle).approve(address(treasury), _amount);\n    ITreasury(treasury).deposit(_amount, principle, profit);\n\n    if (fee != 0) {\n      // fee is transferred to dao\n      IERC20(REQT).safeTransfer(DAO, fee);\n    }\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e16);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n      price_ = bondPrice()\n        .mul(IBondCalculator(bondCalculator).markdown(principle))\n        .div(100);\n    } else {\n      price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice debt ratio in same terms for reserve or liquidity bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    if (isLiquidityBond) {\n      return\n        debtRatio()\n          .mul(IBondCalculator(bondCalculator).markdown(principle))\n          .div(1e9);\n    } else {\n      return debtRatio();\n    }\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/RequiemStableBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemStableBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n  using SafeMath for uint112;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.1% inputAmount for that calculation\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    uint256[] memory reserves = IRequiemStableSwap(_pair).getTokenBalances();\n    uint8 quoteIndex = 1;\n    for (uint8 i = 0; i < reserves.length; i++) {\n      if (i != quoteIndex) {\n        _value += IRequiemStableSwap(_pair).calculateSwap(\n          i,\n          quoteIndex,\n          reserves[i] / 10000\n        );\n      }\n    }\n  }\n\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemStableSwap(_pair).getLpToken().totalSupply();\n\n    _value = totalValue\n      .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n      .div(1e18);\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    // (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(_pair).getReserves();\n    uint256 reserve = 1;\n    // uint256 reserve;\n    // if (IRequiemPair(_pair).token0() == REQT) {\n    //   reserve = reserve1;\n    // } else {\n    //   reserve = reserve0;\n    // }\n    return\n      reserve.mul(2 * (10**IERC20(REQT).decimals())).div(getTotalValue(_pair));\n  }\n}\n"
    },
    "contracts/interfaces/IBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IBondingCalculator {\n  function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\n}\n"
    },
    "contracts/interfaces/IRequiemStableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./ERC20/IERC20.sol\";\n\n// solhint-disable var-name-mixedcase\n\ninterface IRequiemStableSwap {\n\n  // pool data view functions\n  function getLpToken() external view returns (IERC20 lpToken);\n\n  function getA() external view returns (uint256);\n\n  function getAPrecise() external view returns (uint256);\n\n  function getToken(uint8 index) external view returns (IERC20);\n\n  function getTokens() external view returns (IERC20[] memory);\n\n  function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n  function getTokenBalance(uint8 index) external view returns (uint256);\n\n  function getTokenBalances() external view returns (uint256[] memory);\n\n  function getNumberOfTokens() external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n    external\n    view\n    returns (uint256);\n\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateRemoveLiquidity(address account, uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n  function calculateRemoveLiquidityOneToken(\n    address account,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount);\n\n  function getAdminBalances()\n    external\n    view\n    returns (uint256[] memory adminBalances);\n\n  function getAdminBalance(uint8 index) external view returns (uint256);\n\n  function calculateCurrentWithdrawFee(address account)\n    external\n    view\n    returns (uint256);\n\n  // state modifying functions\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    address to,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function addLiquidity(\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n}\n"
    },
    "contracts/interfaces/IRequiemSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IRequiemSwap {\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/RequiemQBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemQBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n  using SafeMath for uint112;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.1% inputAmount for that calculation\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(_pair).getReserves();\n\n    _value = address(IRequiemPair(_pair).token0()) != REQT\n      ? reserve0 +\n        IRequiemSwap(_pair).calculateSwapGivenIn(\n          REQT,\n          IRequiemPair(_pair).token0(),\n          reserve1 / 1000\n        ) *\n        reserve1\n      : reserve1 +\n        IRequiemSwap(_pair).calculateSwapGivenIn(\n          REQT,\n          IRequiemPair(_pair).token1(),\n          reserve0 / 1000\n        ) *\n        reserve0;\n  }\n\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemPair(_pair).totalSupply();\n\n    _value = totalValue\n      .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n      .div(1e18);\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(_pair).getReserves();\n\n    uint256 reserve;\n    if (IRequiemPair(_pair).token0() == REQT) {\n      reserve = reserve1;\n    } else {\n      reserve = reserve0;\n    }\n    return\n      reserve.mul(2 * (10**IERC20(REQT).decimals())).div(getTotalValue(_pair));\n  }\n}\n"
    },
    "contracts/interfaces/IRequiemPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./IRequiemERC20.sol\";\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPair is IRequiemERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n  \n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/RequiemBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemWeightedBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n  using SafeMath for uint112;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.1% inputAmount for that calculation\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(_pair).getReserves();\n\n    _value = address(IRequiemPair(_pair).token0()) != REQT\n      ? reserve0 +\n        IRequiemSwap(_pair).calculateSwapGivenIn(\n          REQT,\n          IRequiemPair(_pair).token0(),\n          reserve1 / 1000\n        ) *\n        reserve1\n      : reserve1 +\n        IRequiemSwap(_pair).calculateSwapGivenIn(\n          REQT,\n          IRequiemPair(_pair).token1(),\n          reserve0 / 1000\n        ) *\n        reserve0;\n  }\n\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemPair(_pair).totalSupply();\n\n    _value = totalValue\n      .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n      .div(1e18);\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(_pair).getReserves();\n\n    uint256 reserve;\n    if (IRequiemPair(_pair).token0() == REQT) {\n      reserve = reserve1;\n    } else {\n      reserve = reserve0;\n    }\n    return\n      reserve.mul(2 * (10**IERC20(REQT).decimals())).div(getTotalValue(_pair));\n  }\n}\n"
    },
    "contracts/mocks/MockBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../libraries/math/FullMath.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\n\ninterface IOwnable {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n\n  function pushManagement(address newOwner_) external;\n\n  function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n  address internal _owner;\n  address internal _newOwner;\n\n  event OwnershipPushed(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event OwnershipPulled(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _owner = msg.sender;\n    emit OwnershipPushed(address(0), _owner);\n  }\n\n  function policy() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyPolicy() {\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceManagement() public virtual override onlyPolicy {\n    emit OwnershipPushed(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function pushManagement(address newOwner_)\n    public\n    virtual\n    override\n    onlyPolicy\n  {\n    require(newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipPushed(_owner, newOwner_);\n    _newOwner = newOwner_;\n  }\n\n  function pullManagement() public virtual override {\n    require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n    emit OwnershipPulled(_owner, _newOwner);\n    _owner = _newOwner;\n  }\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = add(div(a, 2), 1);\n      while (b < c) {\n        c = b;\n        b = div(add(div(a, b), b), 2);\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function toBytes32(address a) internal pure returns (bytes32 b) {\n    assembly {\n      let m := mload(0x40)\n      a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n      mstore(0x40, add(m, 52))\n      b := m\n    }\n  }\n\n  function addressToString(address _address)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes32 _bytes = toBytes32(_address);\n    bytes memory HEX = \"0123456789abcdef\";\n    bytes memory _addr = new bytes(42);\n\n    _addr[0] = \"0\";\n    _addr[1] = \"x\";\n\n    for (uint256 i = 0; i < 20; i++) {\n      _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n      _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n    }\n\n    return string(_addr);\n  }\n}\n\ninterface IERC20 {\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  // TODO comment actual hash value.\n  bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n    keccak256(\"ERC20Token\");\n\n  mapping(address => uint256) internal _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 internal _totalSupply;\n\n  string internal _name;\n\n  string internal _symbol;\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      _allowances[sender][msg.sender].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account_, uint256 ammount_) internal virtual {\n    require(account_ != address(0), \"ERC20: mint to the zero address\");\n    _beforeTokenTransfer(address(this), account_, ammount_);\n    _totalSupply = _totalSupply.add(ammount_);\n    _balances[account_] = _balances[account_].add(ammount_);\n    emit Transfer(address(this), account_, ammount_);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _beforeTokenTransfer(\n    address from_,\n    address to_,\n    uint256 amount_\n  ) internal virtual {}\n}\n\ninterface IERC2612Permit {\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function nonces(address owner) external view returns (uint256);\n}\n\nlibrary Counters {\n  using SafeMath for uint256;\n\n  struct Counter {\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    counter._value += 1;\n  }\n\n  function decrement(Counter storage counter) internal {\n    counter._value = counter._value.sub(1);\n  }\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n  using Counters for Counters.Counter;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant PERMIT_TYPEHASH =\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor() {\n    uint256 chainID;\n    assembly {\n      chainID := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(name())),\n        keccak256(bytes(\"1\")), // Version\n        chainID,\n        address(this)\n      )\n    );\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n    bytes32 hashStruct = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        amount,\n        _nonces[owner].current(),\n        deadline\n      )\n    );\n\n    bytes32 _hash = keccak256(\n      abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n    );\n\n    address signer = ecrecover(_hash, v, r, s);\n    require(\n      signer != address(0) && signer == owner,\n      \"ZeroSwapPermit: Invalid signature\"\n    );\n\n    _nonces[owner].increment();\n    _approve(owner, spender, amount);\n  }\n\n  function nonces(address owner) public view override returns (uint256) {\n    return _nonces[owner].current();\n  }\n}\n\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(\n      value,\n      \"SafeERC20: decreased allowance below zero\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(\n      data,\n      \"SafeERC20: low-level call failed\"\n    );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n\ninterface ITreasury {\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (bool);\n\n  function valueOfToken(address _token, uint256 _amount)\n    external\n    view\n    returns (uint256 value_);\n}\n\ninterface IBondCalculator {\n  function valuation(address _LP, uint256 _amount)\n    external\n    view\n    returns (uint256);\n\n  function markdown(address _LP) external view returns (uint256);\n}\n\ninterface IStaking {\n  function stake(uint256 _amount, address _recipient) external returns (bool);\n}\n\ninterface IStakingHelper {\n  function stake(uint256 _amount, address _recipient) external;\n}\n\ncontract MockBondDepository is Ownable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n  address public immutable bondCalculator; // calculates value of LP tokens\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _bondCalculator\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    // bondCalculator should be address(0) if not LP bond\n    bondCalculator = _bondCalculator;\n    isLiquidityBond = (_bondCalculator != address(0));\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _fee uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _fee,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      fee: _fee,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.FEE) {\n      // 2\n      require(_input <= 10000, \"DAO fee cannot exceed payout\");\n      terms.fee = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOfToken(principle, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    // profits are calculated\n    uint256 fee = payout.mul(terms.fee).div(10000);\n    uint256 profit = value.sub(payout).sub(fee);\n\n    /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) REQT\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(principle).approve(address(treasury), _amount);\n    ITreasury(treasury).deposit(_amount, principle, profit);\n\n    if (fee != 0) {\n      // fee is transferred to dao\n      IERC20(REQT).safeTransfer(DAO, fee);\n    }\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e16);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n      price_ = bondPrice()\n        .mul(IBondCalculator(bondCalculator).markdown(principle))\n        .div(100);\n    } else {\n      price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice debt ratio in same terms for reserve or liquidity bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    if (isLiquidityBond) {\n      return\n        debtRatio()\n          .mul(IBondCalculator(bondCalculator).markdown(principle))\n          .div(1e9);\n    } else {\n      return debtRatio();\n    }\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/RedeemHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./interfaces/IBond.sol\";\n\ncontract RedeemHelper is Manageable {\n  address[] public bonds;\n\n  function redeemAll(address _recipient, bool _stake) external {\n    for (uint256 i = 0; i < bonds.length; i++) {\n      if (bonds[i] != address(0)) {\n        if (IBond(bonds[i]).pendingPayoutFor(_recipient) > 0) {\n          IBond(bonds[i]).redeem(_recipient, _stake);\n        }\n      }\n    }\n  }\n\n  function addBondContract(address _bond) external onlyPolicy {\n    require(_bond != address(0));\n    bonds.push(_bond);\n  }\n\n  function removeBondContract(uint256 _index) external onlyPolicy {\n    bonds[_index] = address(0);\n  }\n}\n"
    },
    "contracts/interfaces/IBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IBond {\n    function redeem( address _recipient, bool _stake ) external returns ( uint );\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}