{
  "address": "0x3Aa5ebB10DC797CAC828524e59A333d0A371443c",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_REQT",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "REQT",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pair",
          "type": "address"
        }
      ],
      "name": "getTotalValue",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pair",
          "type": "address"
        }
      ],
      "name": "markdown",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pair",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount_",
          "type": "uint256"
        }
      ],
      "name": "valuation",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x82e8cf76dfbe496b82a25473ce356fa86aacdaeadbcf248b8201f5f871d61945",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x3Aa5ebB10DC797CAC828524e59A333d0A371443c",
    "transactionIndex": 0,
    "gasUsed": "793452",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfc90fd818ef976996561f20b6ce5b4264a0bf9935dfc00c620201d312bea0ba3",
    "transactionHash": "0x82e8cf76dfbe496b82a25473ce356fa86aacdaeadbcf248b8201f5f871d61945",
    "logs": [],
    "blockNumber": 20,
    "cumulativeGasUsed": "793452",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x610178dA211FEF7D417bC0e6FeD39F05609AD788"
  ],
  "solcInputHash": "33fb797877d98be958f4c888ad0e710c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_REQT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"REQT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"getTotalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"markdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"valuation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getTotalValue(address)\":{\"params\":{\"_pair\":\"general pair that has the RequiemSwap interface implemented  - the value is calculated as the geometric average of input and output  - is consistent with the uniswapV2-type case\"}},\"valuation(address,uint256)\":{\"params\":{\"_pair\":\"general pair that has the RequiemSwap interface implemented\",\"amount_\":\"the amount of LP to price in REQT  - is consistent with the uniswapV2-type case\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getTotalValue(address)\":{\"notice\":\"note for general pairs the price does not necessarily satisfy the conditon that the lp value consists 50% of the one and the other token since the mid price is the quotient of the reserves. That is not necessarily the case for general pairs, therefore, we have to calculate the price separately and apply it to the reserve amount for conversion - calculates the total liquidity value denominated in the provided token - uses the 1bps ouytput reserves for that calculation to avoid slippage to   have a too large impact - the sencond token input argument is ignored when using pools with only 2 tokens\"},\"valuation(address,uint256)\":{\"notice\":\"- calculates the value in reqt of the input LP amount provided\"}},\"notice\":\"Bonding calculator for weighted pairs\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RequiemQBondingCalculator.sol\":\"RequiemQBondingCalculator\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/RequiemQBondingCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./interfaces/IBondingCalculator.sol\\\";\\nimport \\\"./interfaces/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/IRequiemWeightedPair.sol\\\";\\nimport \\\"./interfaces/IRequiemSwap.sol\\\";\\nimport \\\"./libraries/math/FixedPoint.sol\\\";\\nimport \\\"./libraries/math/SqrtMath.sol\\\";\\nimport \\\"./libraries/math/FullMath.sol\\\";\\n\\n/**\\n * Bonding calculator for weighted pairs\\n */\\ncontract RequiemQBondingCalculator is IBondingCalculator {\\n  using FixedPoint for *;\\n\\n  address public immutable REQT;\\n\\n  constructor(address _REQT) {\\n    require(_REQT != address(0));\\n    REQT = _REQT;\\n  }\\n\\n  /**\\n   * note for general pairs the price does not necessarily satisfy the conditon\\n   * that the lp value consists 50% of the one and the other token since the mid\\n   * price is the quotient of the reserves. That is not necessarily the case for\\n   * general pairs, therefore, we have to calculate the price separately and apply it\\n   * to the reserve amount for conversion\\n   * - calculates the total liquidity value denominated in the provided token\\n   * - uses the 1bps ouytput reserves for that calculation to avoid slippage to\\n   *   have a too large impact\\n   * - the sencond token input argument is ignored when using pools with only 2 tokens\\n   * @param _pair general pair that has the RequiemSwap interface implemented\\n   *  - the value is calculated as the geometric average of input and output\\n   *  - is consistent with the uniswapV2-type case\\n   */\\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair)\\n      .getReserves();\\n    (uint32 weight0, uint32 weight1) = IRequiemWeightedPair(_pair)\\n      .getTokenWeights();\\n\\n    (\\n      address otherToken,\\n      uint256 reservesOther,\\n      uint256 reserveReqt,\\n      uint32 weightOther,\\n      uint32 weightReqt\\n    ) = REQT == IRequiemWeightedPair(_pair).token0()\\n        ? (\\n          IRequiemWeightedPair(_pair).token1(),\\n          reserve1,\\n          reserve0,\\n          weight1,\\n          weight0\\n        )\\n        : (\\n          IRequiemWeightedPair(_pair).token0(),\\n          reserve0,\\n          reserve1,\\n          weight0,\\n          weight1\\n        );\\n\\n    uint256 decimals = IERC20(otherToken).decimals() +\\n      IERC20(REQT).decimals() -\\n      IERC20(_pair).decimals();\\n\\n    // In case of both weights being 50, it is equivalent to\\n    // the UniswapV2 variant. If the weights are different, we define the valuation by\\n    // scaling the reqt reserve up or down dependent on the weights and the use the product as\\n    // adjusted constant product. We will use the conservative estimation of the price - we upscale\\n    // such that the reflected equivalent pool is a uniswapV2 with the higher liquidity that pruduces\\n    // the same price of the Requiem token as the weighted pool.\\n    if (weightReqt >= weightOther) {\\n      _value =\\n        SqrtMath.sqrrt(\\n          (reservesOther * weightReqt * reserveReqt) /\\n            weightOther /\\n            (10**decimals)\\n        ) *\\n        2;\\n    } else {\\n      _value =\\n        SqrtMath.sqrrt(\\n          (reservesOther * weightOther * reserveReqt) /\\n            weightReqt /\\n            (10**decimals)\\n        ) *\\n        2;\\n    }\\n  }\\n\\n  /**\\n   * - calculates the value in reqt of the input LP amount provided\\n   * @param _pair general pair that has the RequiemSwap interface implemented\\n   * @param amount_ the amount of LP to price in REQT\\n   *  - is consistent with the uniswapV2-type case\\n   */\\n  function valuation(address _pair, uint256 amount_)\\n    external\\n    view\\n    override\\n    returns (uint256 _value)\\n  {\\n    uint256 totalValue = getTotalValue(_pair);\\n    uint256 totalSupply = IRequiemWeightedPair(_pair).totalSupply();\\n\\n    _value = FullMath.mulDivRoundingUp(totalValue, amount_, totalSupply);\\n  }\\n\\n  function markdown(address _pair) external view returns (uint256) {\\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair)\\n      .getReserves();\\n    (uint32 weight0, uint32 weight1) = IRequiemWeightedPair(_pair)\\n      .getTokenWeights();\\n\\n    (uint256 reservesOther, uint32 weightOther, uint32 weightReqt) = REQT ==\\n      IRequiemWeightedPair(_pair).token0()\\n      ? (reserve1, weight1, weight0)\\n      : (reserve0, weight0, weight1);\\n\\n    // adjusted markdown scaling up the reserve as the trading mechnism allows\\n    // higher or lower valuation for reqt reserve\\n    return\\n      ((reservesOther + (weightReqt * reservesOther) / weightOther) *\\n        10**IERC20(REQT).decimals()) / getTotalValue(_pair);\\n  }\\n}\\n\",\"keccak256\":\"0xe9c2aa80d5be974f2cef7ba37fdaa2d9473560af3e4a2b461cfd00a41bcf4ef0\",\"license\":\"MIT\"},\"contracts/interfaces/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\",\"keccak256\":\"0xc8de46b5781a713fd63eb204be9a9a821aab6468f5ca504ec90c1aec6b8a3bf1\",\"license\":\"MIT\"},\"contracts/interfaces/IBondingCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IBondingCalculator {\\n  function valuation(address pair_, uint256 amount_)\\n    external\\n    view\\n    returns (uint256 _value);\\n}\\n\",\"keccak256\":\"0x7dfca3a4d16834d9182b3521f3b7ce4513e66099ca8499110283a01117171a83\",\"license\":\"MIT\"},\"contracts/interfaces/IRequiemPairERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\n// solhint-disable func-name-mixedcase\\n\\ninterface IRequiemPairERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\",\"keccak256\":\"0xb7fca202d8bf1374b0cc8cb0c510addf9450df8f9df33d940808038a663baef0\",\"license\":\"MIT\"},\"contracts/interfaces/IRequiemSwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\ninterface IRequiemSwap {\\n  function calculateSwapGivenIn(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountIn\\n  ) external view returns (uint256);\\n\\n  function calculateSwapGivenOut(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amountOut\\n  ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xa944abac87a457a7884993de5ec7645708b548bf635540b6f2b85b0460419613\",\"license\":\"MIT\"},\"contracts/interfaces/IRequiemWeightedPair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nimport \\\"./IRequiemPairERC20.sol\\\";\\n\\n// solhint-disable func-name-mixedcase\\n\\ninterface IRequiemWeightedPair is IRequiemPairERC20 {\\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n  event Burn(\\n    address indexed sender,\\n    uint256 amount0,\\n    uint256 amount1,\\n    address indexed to\\n  );\\n  event Swap(\\n    address indexed sender,\\n    uint256 amount0In,\\n    uint256 amount1In,\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function getCollectedFees()\\n    external\\n    view\\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\\n\\n  function getTokenWeights()\\n    external\\n    view\\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\\n\\n  function getSwapFee() external view returns (uint32);\\n\\n  function price0CumulativeLast() external view returns (uint256);\\n\\n  function price1CumulativeLast() external view returns (uint256);\\n\\n  function mint(address to) external returns (uint256 liquidity);\\n\\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(\\n    address,\\n    address,\\n    uint32,\\n    uint32\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe806909eb7975fb3a9368a920ee19c164c013f0ffb00e06c6371592295721815\",\"license\":\"MIT\"},\"contracts/libraries/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./FullMath.sol\\\";\\n\\nlibrary FixedPoint {\\n  struct uq112x112 {\\n    uint224 _x;\\n  }\\n\\n  struct uq144x112 {\\n    uint256 _x;\\n  }\\n\\n  uint8 private constant RESOLUTION = 112;\\n  uint256 private constant Q112 = 0x10000000000000000000000000000;\\n  uint256 private constant Q224 =\\n    0x100000000000000000000000000000000000000000000000000000000;\\n  uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\\n    return uint112(self._x >> RESOLUTION);\\n  }\\n\\n  function decode112with18(uq112x112 memory self)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return uint256(self._x) / 5192296858534827;\\n  }\\n\\n  function fraction(uint256 numerator, uint256 denominator)\\n    internal\\n    pure\\n    returns (uq112x112 memory)\\n  {\\n    require(denominator > 0, \\\"FixedPoint::fraction: division by zero\\\");\\n    if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n    if (numerator <= type(uint144).max) {\\n      uint256 result = (numerator << RESOLUTION) / denominator;\\n      require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\n      return uq112x112(uint224(result));\\n    } else {\\n      uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n      require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\n      return uq112x112(uint224(result));\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1458dee48a18e010fc603e371c30ead771eaff8b1ead78af037c5a6a6a285e72\",\"license\":\"MIT\"},\"contracts/libraries/math/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.11;\\n\\n// solhint-disable no-inline-assembly, reason-string, max-line-length\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            // EDIT for 0.8 compatibility:\\n            // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\\n            uint256 twos = denominator & (~denominator + 1);\\n\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\",\"keccak256\":\"0x2603e02c3be8e366637ac7b8e1d84b8b896b191ce5e25cc0fa6e6d395e832ff1\",\"license\":\"MIT\"},\"contracts/libraries/math/SqrtMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary SqrtMath {\\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\\n    if (a > 3) {\\n      c = a;\\n      uint256 b = a / 2 + 1;\\n      while (b < c) {\\n        c = b;\\n        b = ((a / b) + b) / 2;\\n      }\\n    } else if (a != 0) {\\n      c = 1;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xe1fc577a8b5bb605a7acadceca306bcda1d8ea871cf976a61cd82c4fac4904ac\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051610e19380380610e1983398101604081905261002f91610053565b6001600160a01b03811661004257600080fd5b6001600160a01b0316608052610083565b60006020828403121561006557600080fd5b81516001600160a01b038116811461007c57600080fd5b9392505050565b608051610d606100b9600039600081816056015281816102420152818161028c0152818161055601526106c50152610d606000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806302bb41e51461005157806332da80a3146100955780634249719f146100b657806368637549146100c9575b600080fd5b6100787f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100a86100a33660046109f7565b6100dc565b60405190815260200161008c565b6100a86100c4366004610a14565b610365565b6100a86100d73660046109f7565b6103ed565b6000806000836001600160a01b0316630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa15801561011f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101439190610a72565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150600080856001600160a01b03166332bfe4696040518163ffffffff1660e01b81526004016040805180830381865afa1580156101a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101cc9190610ab5565b915091506000806000886001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa158015610213573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102379190610ae8565b6001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146102775786858561027b565b8584865b92509250925061028a896103ed565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030c9190610b05565b61031790600a610c24565b8363ffffffff16858463ffffffff166103309190610c33565b61033a9190610c68565b6103449086610c8a565b61034e9190610c33565b6103589190610c68565b9998505050505050505050565b600080610371846103ed565b90506000846001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d79190610ca2565b90506103e4828583610875565b95945050505050565b6000806000836001600160a01b0316630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa158015610430573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104549190610a72565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150600080856001600160a01b03166332bfe4696040518163ffffffff1660e01b81526004016040805180830381865afa1580156104b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104dd9190610ab5565b9150915060008060008060008a6001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa158015610527573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054b9190610ae8565b6001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146105ee578a6001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e59190610ae8565b89898989610655565b8a6001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561062c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106509190610ae8565b888a888a5b9450945094509450945060008b6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561069f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c39190610b05565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610721573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107459190610b05565b876001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610783573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a79190610b05565b6107b19190610cbb565b6107bb9190610ce0565b60ff1690508263ffffffff168263ffffffff16106108305761081e6107e182600a610d03565b8463ffffffff16868563ffffffff16896107fb9190610c33565b6108059190610c33565b61080f9190610c68565b6108199190610c68565b6108c0565b610829906002610c33565b9a50610866565b61085861083e82600a610d03565b8363ffffffff16868663ffffffff16896107fb9190610c33565b610863906002610c33565b9a505b50505050505050505050919050565b6000610882848484610930565b90506000828061089457610894610c52565b84860911156108b95760001981106108ab57600080fd5b806108b581610d0f565b9150505b9392505050565b6000600382111561092157508060006108da600283610c68565b6108e5906001610c8a565b90505b8181101561091b579050806002816109008186610c68565b61090a9190610c8a565b6109149190610c68565b90506108e8565b50919050565b811561092b575060015b919050565b60008080600019858709858702925082811083820303915050806000141561096a576000841161095f57600080fd5b5082900490506108b9565b80841161097657600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b6001600160a01b03811681146109f457600080fd5b50565b600060208284031215610a0957600080fd5b81356108b9816109df565b60008060408385031215610a2757600080fd5b8235610a32816109df565b946020939093013593505050565b80516dffffffffffffffffffffffffffff8116811461092b57600080fd5b805163ffffffff8116811461092b57600080fd5b600080600060608486031215610a8757600080fd5b610a9084610a40565b9250610a9e60208501610a40565b9150610aac60408501610a5e565b90509250925092565b60008060408385031215610ac857600080fd5b610ad183610a5e565b9150610adf60208401610a5e565b90509250929050565b600060208284031215610afa57600080fd5b81516108b9816109df565b600060208284031215610b1757600080fd5b815160ff811681146108b957600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115610b79578160001904821115610b5f57610b5f610b28565b80851615610b6c57918102915b93841c9390800290610b43565b509250929050565b600082610b9057506001610c1e565b81610b9d57506000610c1e565b8160018114610bb35760028114610bbd57610bd9565b6001915050610c1e565b60ff841115610bce57610bce610b28565b50506001821b610c1e565b5060208310610133831016604e8410600b8410161715610bfc575081810a610c1e565b610c068383610b3e565b8060001904821115610c1a57610c1a610b28565b0290505b92915050565b60006108b960ff841683610b81565b6000816000190483118215151615610c4d57610c4d610b28565b500290565b634e487b7160e01b600052601260045260246000fd5b600082610c8557634e487b7160e01b600052601260045260246000fd5b500490565b60008219821115610c9d57610c9d610b28565b500190565b600060208284031215610cb457600080fd5b5051919050565b600060ff821660ff84168060ff03821115610cd857610cd8610b28565b019392505050565b600060ff821660ff841680821015610cfa57610cfa610b28565b90039392505050565b60006108b98383610b81565b6000600019821415610d2357610d23610b28565b506001019056fea264697066735822122000f712b20a1e8f06f81ec469a8d87125c1fd9a88ef08d51f0ee321f8b49ea31864736f6c634300080b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806302bb41e51461005157806332da80a3146100955780634249719f146100b657806368637549146100c9575b600080fd5b6100787f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100a86100a33660046109f7565b6100dc565b60405190815260200161008c565b6100a86100c4366004610a14565b610365565b6100a86100d73660046109f7565b6103ed565b6000806000836001600160a01b0316630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa15801561011f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101439190610a72565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150600080856001600160a01b03166332bfe4696040518163ffffffff1660e01b81526004016040805180830381865afa1580156101a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101cc9190610ab5565b915091506000806000886001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa158015610213573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102379190610ae8565b6001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146102775786858561027b565b8584865b92509250925061028a896103ed565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030c9190610b05565b61031790600a610c24565b8363ffffffff16858463ffffffff166103309190610c33565b61033a9190610c68565b6103449086610c8a565b61034e9190610c33565b6103589190610c68565b9998505050505050505050565b600080610371846103ed565b90506000846001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d79190610ca2565b90506103e4828583610875565b95945050505050565b6000806000836001600160a01b0316630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa158015610430573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104549190610a72565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150600080856001600160a01b03166332bfe4696040518163ffffffff1660e01b81526004016040805180830381865afa1580156104b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104dd9190610ab5565b9150915060008060008060008a6001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa158015610527573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054b9190610ae8565b6001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146105ee578a6001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e59190610ae8565b89898989610655565b8a6001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561062c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106509190610ae8565b888a888a5b9450945094509450945060008b6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561069f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c39190610b05565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610721573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107459190610b05565b876001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610783573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a79190610b05565b6107b19190610cbb565b6107bb9190610ce0565b60ff1690508263ffffffff168263ffffffff16106108305761081e6107e182600a610d03565b8463ffffffff16868563ffffffff16896107fb9190610c33565b6108059190610c33565b61080f9190610c68565b6108199190610c68565b6108c0565b610829906002610c33565b9a50610866565b61085861083e82600a610d03565b8363ffffffff16868663ffffffff16896107fb9190610c33565b610863906002610c33565b9a505b50505050505050505050919050565b6000610882848484610930565b90506000828061089457610894610c52565b84860911156108b95760001981106108ab57600080fd5b806108b581610d0f565b9150505b9392505050565b6000600382111561092157508060006108da600283610c68565b6108e5906001610c8a565b90505b8181101561091b579050806002816109008186610c68565b61090a9190610c8a565b6109149190610c68565b90506108e8565b50919050565b811561092b575060015b919050565b60008080600019858709858702925082811083820303915050806000141561096a576000841161095f57600080fd5b5082900490506108b9565b80841161097657600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b6001600160a01b03811681146109f457600080fd5b50565b600060208284031215610a0957600080fd5b81356108b9816109df565b60008060408385031215610a2757600080fd5b8235610a32816109df565b946020939093013593505050565b80516dffffffffffffffffffffffffffff8116811461092b57600080fd5b805163ffffffff8116811461092b57600080fd5b600080600060608486031215610a8757600080fd5b610a9084610a40565b9250610a9e60208501610a40565b9150610aac60408501610a5e565b90509250925092565b60008060408385031215610ac857600080fd5b610ad183610a5e565b9150610adf60208401610a5e565b90509250929050565b600060208284031215610afa57600080fd5b81516108b9816109df565b600060208284031215610b1757600080fd5b815160ff811681146108b957600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115610b79578160001904821115610b5f57610b5f610b28565b80851615610b6c57918102915b93841c9390800290610b43565b509250929050565b600082610b9057506001610c1e565b81610b9d57506000610c1e565b8160018114610bb35760028114610bbd57610bd9565b6001915050610c1e565b60ff841115610bce57610bce610b28565b50506001821b610c1e565b5060208310610133831016604e8410600b8410161715610bfc575081810a610c1e565b610c068383610b3e565b8060001904821115610c1a57610c1a610b28565b0290505b92915050565b60006108b960ff841683610b81565b6000816000190483118215151615610c4d57610c4d610b28565b500290565b634e487b7160e01b600052601260045260246000fd5b600082610c8557634e487b7160e01b600052601260045260246000fd5b500490565b60008219821115610c9d57610c9d610b28565b500190565b600060208284031215610cb457600080fd5b5051919050565b600060ff821660ff84168060ff03821115610cd857610cd8610b28565b019392505050565b600060ff821660ff841680821015610cfa57610cfa610b28565b90039392505050565b60006108b98383610b81565b6000600019821415610d2357610d23610b28565b506001019056fea264697066735822122000f712b20a1e8f06f81ec469a8d87125c1fd9a88ef08d51f0ee321f8b49ea31864736f6c634300080b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getTotalValue(address)": {
        "params": {
          "_pair": "general pair that has the RequiemSwap interface implemented  - the value is calculated as the geometric average of input and output  - is consistent with the uniswapV2-type case"
        }
      },
      "valuation(address,uint256)": {
        "params": {
          "_pair": "general pair that has the RequiemSwap interface implemented",
          "amount_": "the amount of LP to price in REQT  - is consistent with the uniswapV2-type case"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getTotalValue(address)": {
        "notice": "note for general pairs the price does not necessarily satisfy the conditon that the lp value consists 50% of the one and the other token since the mid price is the quotient of the reserves. That is not necessarily the case for general pairs, therefore, we have to calculate the price separately and apply it to the reserve amount for conversion - calculates the total liquidity value denominated in the provided token - uses the 1bps ouytput reserves for that calculation to avoid slippage to   have a too large impact - the sencond token input argument is ignored when using pools with only 2 tokens"
      },
      "valuation(address,uint256)": {
        "notice": "- calculates the value in reqt of the input LP amount provided"
      }
    },
    "notice": "Bonding calculator for weighted pairs",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}