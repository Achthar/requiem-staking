{
  "language": "Solidity",
  "sources": {
    "contracts/FundDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Ownable.sol\";\nimport \"./libraries/Initializable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ERC20.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/ERC20/IRewardToken.sol\";\n\ncontract FundDistributor is Ownable, Initializable {\n  using SafeERC20 for IRewardToken;\n\n  IRewardToken public reward;\n  uint256 public missingDecimals;\n\n  // CONTRACTS\n  mapping(address => bool) public requesters;\n\n  /* ========== MODIFIER ========== */\n\n  modifier onlyRequester() {\n    require(requesters[msg.sender], \"Only pool can request transfer\");\n    _;\n  }\n\n  function initialize(address _reward) external initializer {\n    reward = IRewardToken(_reward);\n    missingDecimals = 18 - ERC20(_reward).decimals();\n  }\n\n  /* ========== MUTATIVE ====================== */\n\n  function distributeTo(address _receiver, uint256 _amount)\n    public\n    onlyRequester\n  {\n    require(_receiver != address(0), \"Invalid address\");\n    if (_amount > 0) {\n      reward.mint(_receiver, _amount / (10**missingDecimals));\n    }\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function addRequester(address _requester) external onlyOwner {\n    require(!requesters[_requester], \"requester existed\");\n    requesters[_requester] = true;\n    emit RequesterAdded(_requester);\n  }\n\n  function removeRequester(address _requester) external onlyOwner {\n    require(requesters[_requester], \"requester not found\");\n    delete requesters[_requester];\n    emit RequesterRemoved(_requester);\n  }\n\n  /* ========== EVENTS ========================= */\n\n  event RequesterAdded(address indexed requester);\n  event RequesterRemoved(address indexed requester);\n  event FundRequested(uint256 indexed amount);\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../interfaces/IOwnable.sol\";\n\ncontract Ownable is IOwnable {\n    \n  address internal _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () {\n    _owner = msg.sender;\n    emit OwnershipTransferred( address(0), _owner );\n  }\n\n  function owner() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n    _;\n  }\n\n  function renounceOwnership() public virtual override onlyOwner() {\n    emit OwnershipTransferred( _owner, address(0) );\n    _owner = address(0);\n  }\n\n  function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n    require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred( _owner, newOwner_ );\n    _owner = newOwner_;\n  }\n}"
    },
    "contracts/libraries/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}"
    },
    "contracts/interfaces/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/libraries/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 internal _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override(IERC20, IERC20Metadata) returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce gas costs.\n// The `safeTransfer` and `safeTransferFrom` functions assume that `token` is a contract (an account with code), and\n// work differently from the OpenZeppelin version if it is not.\n\npragma solidity ^0.8.11;\n\nimport \"./helpers/RequiemErrors.sol\";\n\nimport \"../interfaces/ERC20/IERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   *\n   * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\n   */\n  function _callOptionalReturn(address token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves.\n    (bool success, bytes memory returndata) = token.call(data);\n\n    // If the low-level call didn't succeed we return whatever was returned from it.\n    assembly {\n      if eq(success, 0) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\n    RequiemErrors._require(\n      returndata.length == 0 || abi.decode(returndata, (bool)),\n      Errors.SAFE_ERC20_CALL_FAILED\n    );\n  }\n}\n"
    },
    "contracts/interfaces/ERC20/IRewardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IRewardToken is IERC20 {\n    function mint(address _recipient, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n  \n  function transferOwnership( address newOwner_ ) external;\n}"
    },
    "contracts/interfaces/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/libraries/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/libraries/helpers/RequiemErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.11;\n\n// solhint-disable\nlibrary RequiemErrors {\n    /**\n     * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n     * supported.\n     */\n    function _require(bool condition, uint256 errorCode) internal pure {\n        if (!condition) RequiemErrors._revert(errorCode);\n    }\n\n    /**\n     * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n     */\n    function _revert(uint256 errorCode) internal pure {\n        // We're going to dynamically create a revert string based on the error code, with the following format:\n        // 'REQ#{errorCode}'\n        // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n        //\n        // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n        // number (8 to 16 bits) than the individual string characters.\n        //\n        // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n        // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n        // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n        assembly {\n            // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n            // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n            // the '0' character.\n\n            let units := add(mod(errorCode, 10), 0x30)\n\n            errorCode := div(errorCode, 10)\n            let tenths := add(mod(errorCode, 10), 0x30)\n\n            errorCode := div(errorCode, 10)\n            let hundreds := add(mod(errorCode, 10), 0x30)\n\n            // With the individual characters, we can now construct the full string. The \"REQ#\" part is a known constant\n            // (0x52455123): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n            // characters to it, each shifted by a multiple of 8.\n            // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n            // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n            // array).\n\n            let revertReason := shl(200, add(0x52455123000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n            // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n            // message will have the following layout:\n            // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n            // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n            // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n            mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n            mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n            // The string length is fixed: 7 characters.\n            mstore(0x24, 7)\n            // Finally, the string itself is stored.\n            mstore(0x44, revertReason)\n\n            // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n            // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n            revert(0, 100)\n        }\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n"
    },
    "contracts/StakingWarmup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract StakingWarmup {\n\n    address public immutable staking;\n    address public immutable sREQT;\n\n    constructor ( address _staking, address _sREQT ) {\n        require( _staking != address(0) );\n        staking = _staking;\n        require( _sREQT != address(0) );\n        sREQT = _sREQT;\n    }\n\n    function retrieve( address _staker, uint _amount ) external {\n        require( msg.sender == staking );\n        IERC20( sREQT ).transfer( _staker, _amount );\n    }\n}"
    },
    "contracts/StakingHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract StakingHelper {\n\n    address public immutable staking;\n    address public immutable REQT;\n\n    constructor ( address _staking, address _REQT ) {\n        require( _staking != address(0) );\n        staking = _staking;\n        require( _REQT != address(0) );\n        REQT = _REQT;\n    }\n\n    function stake( uint _amount ) external {\n        IERC20( REQT ).transferFrom( msg.sender, address(this), _amount );\n        IERC20( REQT ).approve( staking, _amount );\n        IStaking( staking ).stake( _amount, msg.sender );\n        IStaking( staking ).claim( msg.sender );\n    }\n}"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IStaking {\n  function stake(uint256 _amount, address _recipient) external returns (bool);\n\n  function claim(address _recipient) external;\n\n  function unstake(uint256 _amount, address _recipient) external returns (bool);\n\n  function index() external view returns (uint256);\n}\n"
    },
    "contracts/wREQT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/ERC20.sol\";\nimport \"./interfaces/IStaking.sol\";\n\ncontract wREQT is ERC20 {\n  using SafeERC20 for ERC20;\n\n  address public immutable staking;\n  address public immutable REQT;\n  address public immutable sREQT;\n\n  constructor(\n    address _staking,\n    address _REQT,\n    address _sREQT\n  ) ERC20(\"Wrapped sREQT\", \"wsREQT\", 18) {\n    require(_staking != address(0));\n    staking = _staking;\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_sREQT != address(0));\n    sREQT = _sREQT;\n  }\n\n  /**\n        @notice stakes REQT and wraps sREQT\n        @param _amount uint\n        @return uint\n     */\n  function wrapFromREQT(uint256 _amount) external returns (uint256) {\n    IERC20(REQT).transferFrom(msg.sender, address(this), _amount);\n\n    IERC20(REQT).approve(staking, _amount); // stake REQT for sREQT\n    IStaking(staking).stake(_amount, address(this));\n\n    uint256 value = wREQTValue(_amount);\n    _mint(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice unwrap sREQT and unstake REQT\n        @param _amount uint\n        @return uint\n     */\n  function unwrapToREQT(uint256 _amount) external returns (uint256) {\n    _burn(msg.sender, _amount);\n\n    uint256 value = sREQTValue(_amount);\n    IERC20(sREQT).approve(staking, value); // unstake sREQT for REQT\n    IStaking(staking).unstake(value, address(this));\n\n    IERC20(REQT).transfer(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice wrap sREQT\n        @param _amount uint\n        @return uint\n     */\n  function wrapFromsREQT(uint256 _amount) external returns (uint256) {\n    IERC20(sREQT).transferFrom(msg.sender, address(this), _amount);\n\n    uint256 value = wREQTValue(_amount);\n    _mint(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice unwrap sREQT\n        @param _amount uint\n        @return uint\n     */\n  function unwrapTosREQT(uint256 _amount) external returns (uint256) {\n    _burn(msg.sender, _amount);\n\n    uint256 value = sREQTValue(_amount);\n    IERC20(sREQT).transfer(msg.sender, value);\n    return value;\n  }\n\n  /**\n        @notice converts wREQT amount to sREQT\n        @param _amount uint\n        @return uint\n     */\n  function sREQTValue(uint256 _amount) public view returns (uint256) {\n    return (_amount * IStaking(staking).index()) / (10**decimals());\n  }\n\n  /**\n        @notice converts sREQT amount to wREQT\n        @param _amount uint\n        @return uint\n     */\n  function wREQTValue(uint256 _amount) public view returns (uint256) {\n    return (_amount * 10**decimals()) / IStaking(staking).index();\n  }\n}\n"
    },
    "contracts/libraries/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Permit.sol\";\nimport \"./EIP712.sol\";\n\n// solhint-disable no-empty-blocks\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n  mapping(address => uint256) private _nonces;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\n      \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n   *\n   * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n   */\n  constructor(string memory name) EIP712(name, \"1\") {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"EXPIRED_PERMIT\");\n\n    uint256 nonce = _nonces[owner];\n    bytes32 structHash = keccak256(\n      abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline)\n    );\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ecrecover(hash, v, r, s);\n    require((signer != address(0)) && (signer == owner), \"INVALID_SIGNATURE\");\n\n    _nonces[owner] = nonce + 1;\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n   */\n  function nonces(address owner) public view override returns (uint256) {\n    return _nonces[owner];\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/libraries/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // Silence state mutability warning without generating bytecode.\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\n        // https://github.com/ethereum/solidity/issues/2691\n        this;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/sRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./libraries/Manageable.sol\";\n\ncontract sRequiem is ERC20Permit, Manageable {\n  modifier onlyStakingContract() {\n    require(msg.sender == stakingContract);\n    _;\n  }\n\n  address public stakingContract;\n  address public initializer;\n\n  event LogSupply(\n    uint256 indexed epoch,\n    uint256 timestamp,\n    uint256 _totalSupply\n  );\n  event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n  event LogStakingContractUpdated(address stakingContract);\n\n  struct Rebase {\n    uint256 epoch;\n    uint256 rebase; // 18 decimals\n    uint256 totalStakedBefore;\n    uint256 totalStakedAfter;\n    uint256 amountRebased;\n    uint256 index;\n    uint256 blockNumberOccured;\n  }\n  Rebase[] public rebases;\n\n  uint256 public INDEX;\n\n  uint256 private constant MAX_UINT256 = ~uint256(0);\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**9;\n\n  // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n  // Use the highest value that fits in a uint256 for max granularity.\n  uint256 private constant TOTAL_GONS =\n    MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n  // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\n  uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n\n  uint256 private _gonsPerFragment;\n  mapping(address => uint256) private _gonBalances;\n\n  mapping(address => mapping(address => uint256)) private _allowedValue;\n\n  constructor() ERC20(\"Staked Requiem\", \"sREQT\", 9) ERC20Permit(\"sREQT\") {\n    initializer = msg.sender;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonsPerFragment = TOTAL_GONS / _totalSupply;\n  }\n\n  function initialize(address stakingContract_) external returns (bool) {\n    require(msg.sender == initializer);\n    require(stakingContract_ != address(0));\n    stakingContract = stakingContract_;\n    _gonBalances[stakingContract] = TOTAL_GONS;\n\n    emit Transfer(address(0x0), stakingContract, _totalSupply);\n    emit LogStakingContractUpdated(stakingContract_);\n\n    initializer = address(0);\n    return true;\n  }\n\n  function setIndex(uint256 _INDEX) external onlyManager returns (bool) {\n    require(INDEX == 0);\n    INDEX = gonsForBalance(_INDEX);\n    return true;\n  }\n\n  /**\n        @notice increases sREQT supply to increase staking balances relative to profit_\n        @param profit_ uint256\n        @return uint256\n     */\n  function rebase(uint256 profit_, uint256 epoch_)\n    public\n    onlyStakingContract\n    returns (uint256)\n  {\n    uint256 rebaseAmount;\n    uint256 circulatingSupply_ = circulatingSupply();\n\n    if (profit_ == 0) {\n      emit LogSupply(epoch_, block.timestamp, _totalSupply);\n      emit LogRebase(epoch_, 0, index());\n      return _totalSupply;\n    } else if (circulatingSupply_ > 0) {\n      rebaseAmount = (profit_ * _totalSupply) / circulatingSupply_;\n    } else {\n      rebaseAmount = profit_;\n    }\n\n    _totalSupply = _totalSupply + rebaseAmount;\n\n    if (_totalSupply > MAX_SUPPLY) {\n      _totalSupply = MAX_SUPPLY;\n    }\n\n    _gonsPerFragment = TOTAL_GONS / _totalSupply;\n\n    _storeRebase(circulatingSupply_, profit_, epoch_);\n\n    return _totalSupply;\n  }\n\n  /**\n        @notice emits event with data about rebase\n        @param previousCirculating_ uint\n        @param profit_ uint\n        @param epoch_ uint\n        @return bool\n     */\n  function _storeRebase(\n    uint256 previousCirculating_,\n    uint256 profit_,\n    uint256 epoch_\n  ) internal returns (bool) {\n    uint256 rebasePercent = (profit_ * 1e18) / previousCirculating_;\n\n    rebases.push(\n      Rebase({\n        epoch: epoch_,\n        rebase: rebasePercent, // 18 decimals\n        totalStakedBefore: previousCirculating_,\n        totalStakedAfter: circulatingSupply(),\n        amountRebased: profit_,\n        index: index(),\n        blockNumberOccured: block.number\n      })\n    );\n\n    emit LogSupply(epoch_, block.timestamp, _totalSupply);\n    emit LogRebase(epoch_, rebasePercent, index());\n\n    return true;\n  }\n\n  function balanceOf(address who) public view override returns (uint256) {\n    return _gonBalances[who] / _gonsPerFragment;\n  }\n\n  function gonsForBalance(uint256 amount) public view returns (uint256) {\n    return amount * _gonsPerFragment;\n  }\n\n  function balanceForGons(uint256 gons) public view returns (uint256) {\n    return gons / _gonsPerFragment;\n  }\n\n  // Staking contract holds excess sREQT\n  function circulatingSupply() public view returns (uint256) {\n    return _totalSupply - balanceOf(stakingContract);\n  }\n\n  function index() public view returns (uint256) {\n    return balanceForGons(INDEX);\n  }\n\n  function transfer(address to, uint256 value) public override returns (bool) {\n    uint256 gonValue = value * _gonsPerFragment;\n    _gonBalances[msg.sender] -= gonValue;\n    _gonBalances[to] += gonValue;\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function allowance(address owner_, address spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _allowedValue[owner_][spender];\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) public override returns (bool) {\n    _allowedValue[from][msg.sender] -= value;\n    emit Approval(from, msg.sender, _allowedValue[from][msg.sender]);\n\n    uint256 gonValue = gonsForBalance(value);\n    _gonBalances[from] = _gonBalances[from] - gonValue;\n    _gonBalances[to] = _gonBalances[to] + gonValue;\n    emit Transfer(from, to, value);\n\n    return true;\n  }\n\n  function approve(address spender, uint256 value)\n    public\n    override\n    returns (bool)\n  {\n    _allowedValue[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  // What gets called in a permit\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  ) internal virtual override {\n    _allowedValue[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    override\n    returns (bool)\n  {\n    _allowedValue[msg.sender][spender] += addedValue;\n    emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    override\n    returns (bool)\n  {\n    uint256 oldValue = _allowedValue[msg.sender][spender];\n    if (subtractedValue >= oldValue) {\n      _allowedValue[msg.sender][spender] = 0;\n    } else {\n      _allowedValue[msg.sender][spender] = oldValue - subtractedValue;\n    }\n    emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/Manageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"../interfaces/IManageable.sol\";\n\ncontract Manageable is IManageable {\n\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipPushed( address(0), _owner );\n    }\n\n    function policy() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyPolicy() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    modifier onlyManager() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyPolicy() {\n        emit OwnershipPushed( _owner, address(0) );\n        _owner = address(0);\n    }\n\n    function pushManagement( address newOwner_ ) public virtual override onlyPolicy() {\n        require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipPushed( _owner, newOwner_ );\n        _newOwner = newOwner_;\n    }\n    \n    function pullManagement() public virtual override {\n        require( msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled( _owner, _newOwner );\n        _owner = _newOwner;\n    }\n}"
    },
    "contracts/interfaces/IManageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n\ninterface IManageable {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}"
    },
    "contracts/wETHBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IAggragatorV3.sol\";\n\ncontract RequiemWETHBondDepository is Manageable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  IAggragatorV3 internal priceFeed;\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _feed\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    require(_feed != address(0));\n    priceFeed = IAggragatorV3(_feed);\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(currentDebt() == 0, \"Debt must be 0 for initialization\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= (terms.controlVariable * 25) / 1000,\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOf(principle, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    /**\n            asset carries risk and is not minted against\n            asset transfered to treasury and rewards minted as payout\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, treasury, _amount);\n    ITreasury(treasury).mintRewards(address(this), payout);\n\n    // total debt is increased\n    totalDebt += value;\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout + payout,\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number + terms.vestingTerm,\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = (info.payout * percentVested) / 10000;\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout - payout,\n        vesting: info.vesting - (block.number - info.lastBlock),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock + adjustment.buffer;\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable += adjustment.rate;\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable -= adjustment.rate;\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt -= debtDecay();\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return (IERC20(REQT).totalSupply() * terms.maxPayout) / 100000;\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18() / 1e14;\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = (terms.controlVariable * debtRatio()) / 1e5;\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = (terms.controlVariable * debtRatio()) / 1e5;\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice get asset price from chainlink\n   */\n  function assetPrice() public view returns (int256) {\n    (, int256 price, , , ) = priceFeed.latestRoundData();\n    return price;\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    price_ = bondPrice() * (uint256(assetPrice())) * 1e6;\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ =\n      FixedPoint.fraction(currentDebt() * 1e9, supply).decode112with18() /\n      1e18;\n  }\n\n  /**\n   *  @notice debt ratio in same terms as reserve bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    return (debtRatio() * uint256(assetPrice())) / 1e8; // ETH feed is 8 decimals\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt - debtDecay();\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number - lastDecay;\n    decay_ = (totalDebt * blocksSinceLast) / terms.vestingTerm;\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number - bond.lastBlock;\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = (blocksSinceLast * 10000) / vesting;\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = (payout * percentVested) / 10000;\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./FullMath.sol\";\n\nlibrary FixedPoint {\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  struct uq144x112 {\n    uint256 _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint256 private constant Q112 = 0x10000000000000000000000000000;\n  uint256 private constant Q224 =\n    0x100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  function decode112with18(uq112x112 memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return uint256(self._x) / 5192296858534827;\n  }\n\n  function fraction(uint256 numerator, uint256 denominator)\n    internal\n    pure\n    returns (uq112x112 memory)\n  {\n    require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n    if (numerator == 0) return FixedPoint.uq112x112(0);\n\n    if (numerator <= type(uint144).max) {\n      uint256 result = (numerator << RESOLUTION) / denominator;\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    } else {\n      uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    }\n  }\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface ITreasury {\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (uint256 send_);\n\n  function valueOf(address _token, uint256 _amount)\n    external\n    view\n    returns (uint256 value_);\n\n  function mintRewards(address _recipient, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IStakingHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IStakingHelper {\n  function stake(uint256 _amount, address _recipient) external;\n}\n"
    },
    "contracts/interfaces/IAggragatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IAggragatorV3 {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/libraries/math/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.11;\n\n// solhint-disable no-inline-assembly, reason-string, max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            // EDIT for 0.8 compatibility:\n            // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\n            uint256 twos = denominator & (~denominator + 1);\n\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}"
    },
    "contracts/RequiemQBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IBondCalculator.sol\";\n\ncontract RequiemQBondDepository is Manageable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n  address public immutable bondCalculator; // calculates value of LP tokens\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _bondCalculator\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    // bondCalculator should be address(0) if not LP bond\n    bondCalculator = _bondCalculator;\n    isLiquidityBond = (_bondCalculator != address(0));\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _fee uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _fee,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      fee: _fee,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.FEE) {\n      // 2\n      require(_input <= 10000, \"DAO fee cannot exceed payout\");\n      terms.fee = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= (terms.controlVariable * 25) / 1000,\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOf(principle, _amount);\n\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    // profits are calculated\n    uint256 fee = (payout * terms.fee) / 10000;\n    require(value > payout + fee, \"VALUE is less than payout plus fee\");\n    uint256 profit = value - payout - fee;\n\n    /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) REQT\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(principle).approve(address(treasury), _amount);\n    ITreasury(treasury).deposit(_amount, principle, profit);\n\n    if (fee != 0) {\n      // fee is transferred to dao\n      IERC20(REQT).safeTransfer(DAO, fee);\n    }\n\n    // total debt is increased\n    totalDebt = totalDebt + value;\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout + payout,\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number + terms.vestingTerm,\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = (info.payout * percentVested) / 10000;\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout - payout,\n        vesting: info.vesting - (block.number - info.lastBlock),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock + adjustment.buffer;\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable + adjustment.rate;\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable - adjustment.rate;\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt -= debtDecay();\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return (IERC20(REQT).totalSupply() * terms.maxPayout) / 100000;\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18() / 1e16;\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = (terms.controlVariable * debtRatio() + 1000000000) / 1e7;\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = (terms.controlVariable * debtRatio() + 1000000000) / 1e7;\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n      price_ =\n        (bondPrice() * IBondCalculator(bondCalculator).markdown(principle)) /\n        100;\n    } else {\n      price_ = (bondPrice() * 10**IERC20(principle).decimals()) / 100;\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ =\n      FixedPoint.fraction(currentDebt() * 1e9, supply).decode112with18() /\n      1e18;\n  }\n\n  /**\n   *  @notice debt ratio in same terms for reserve or liquidity bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    if (isLiquidityBond) {\n      return\n        (debtRatio() * IBondCalculator(bondCalculator).markdown(principle)) /\n        1e9;\n    } else {\n      return debtRatio();\n    }\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt - debtDecay();\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number - lastDecay;\n    decay_ = (totalDebt * blocksSinceLast) / terms.vestingTerm;\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number - bond.lastBlock;\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = (blocksSinceLast * 10000) / vesting;\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = (payout * percentVested) / 10000;\n    }\n  }\n\n  // a view function that shows the full data at once\n  function viewBondData()\n    external\n    view\n    returns (\n      uint256 _bondPrice_,\n      uint256 _bondPriceInUsd_,\n      uint256 _currentDebt_\n    )\n  {\n    _currentDebt_ = totalDebt - debtDecay();\n\n    _bondPrice_ = (terms.controlVariable * debtRatio() + 1000000000) / 1e7;\n    if (_bondPrice_ < terms.minimumPrice) {\n      _bondPrice_ = terms.minimumPrice;\n    }\n\n    if (isLiquidityBond) {\n      _bondPriceInUsd_ =\n        (bondPrice() * IBondCalculator(bondCalculator).markdown(principle)) /\n        100;\n    } else {\n      _bondPriceInUsd_ = (bondPrice() * 10**IERC20(principle).decimals()) / 100;\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/interfaces/IBondCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IBondCalculator {\n  function valuation(address _LP, uint256 _amount)\n    external\n    view\n    returns (uint256);\n\n  function markdown(address _LP) external view returns (uint256);\n}\n"
    },
    "contracts/RequiemCVXBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/PolicyOwned.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IBondCalculator.sol\";\n\ncontract RequiemCVXBondDepository is PolicyOwned {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principal; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principal\n  address public immutable DAO; // receives profit share from bond\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principal value. 4 decimals (1500 = 0.15)\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principal,\n    address _treasury,\n    address _DAO\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principal != address(0));\n    principal = _principal;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(currentDebt() == 0, \"Debt must be 0 for initialization\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOf(principal, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    /**\n            asset carries risk and is not minted against\n            asset transfered to treasury and rewards minted as payout\n         */\n    IERC20(principal).safeTransferFrom(msg.sender, treasury, _amount);\n    ITreasury(treasury).mintRewards(address(this), payout);\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: nativePrice\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      nativePrice\n    );\n    emit BondPriceChanged(_bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).safeTransfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e14);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).div(1e5);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).div(1e5);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principal or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principal);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/PolicyOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"../interfaces/IPolicyOwned.sol\";\n\ncontract PolicyOwned is IPolicyOwned {\n  address internal _owner;\n  address internal _newOwner;\n\n  event OwnershipPushed(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event OwnershipPulled(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _owner = msg.sender;\n    emit OwnershipPushed(address(0), _owner);\n  }\n\n  function policy() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyPolicy() {\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceManagement() public virtual override onlyPolicy {\n    emit OwnershipPushed(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function pushManagement(address newOwner_)\n    public\n    virtual\n    override\n    onlyPolicy\n  {\n    require(newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipPushed(_owner, newOwner_);\n    _newOwner = newOwner_;\n  }\n\n  function pullManagement() public virtual override {\n    require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n    emit OwnershipPulled(_owner, _newOwner);\n    _owner = _newOwner;\n  }\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = add(div(a, 2), 1);\n      while (b < c) {\n        c = b;\n        b = div(add(div(a, b), b), 2);\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IPolicyOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IPolicyOwned {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}"
    },
    "contracts/StakingDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/Policy.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\ncontract Distributor is Policy {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n    \n    \n    \n    /* ====== VARIABLES ====== */\n\n    address public immutable OHM;\n    address public immutable treasury;\n    \n    uint public immutable epochLength;\n    uint public nextEpochBlock;\n    \n    mapping( uint => Adjust ) public adjustments;\n    \n    \n    /* ====== STRUCTS ====== */\n        \n    struct Info {\n        uint rate; // in ten-thousandths ( 5000 = 0.5% )\n        address recipient;\n    }\n    Info[] public info;\n    \n    struct Adjust {\n        bool add;\n        uint rate;\n        uint target;\n    }\n    \n    \n    \n    /* ====== CONSTRUCTOR ====== */\n\n    constructor( address _treasury, address _ohm, uint _epochLength, uint _nextEpochBlock ) {        \n        require( _treasury != address(0) );\n        treasury = _treasury;\n        require( _ohm != address(0) );\n        OHM = _ohm;\n        epochLength = _epochLength;\n        nextEpochBlock = _nextEpochBlock;\n    }\n    \n    \n    \n    /* ====== PUBLIC FUNCTIONS ====== */\n    \n    /**\n        @notice send epoch reward to staking contract\n     */\n    function distribute() external returns ( bool ) {\n        if ( nextEpochBlock <= block.number ) {\n            nextEpochBlock = nextEpochBlock.add( epochLength ); // set next epoch block\n            \n            // distribute rewards to each recipient\n            for ( uint i = 0; i < info.length; i++ ) {\n                if ( info[ i ].rate > 0 ) {\n                    ITreasury( treasury ).mintRewards( // mint and send from treasury\n                        info[ i ].recipient, \n                        nextRewardAt( info[ i ].rate ) \n                    );\n                    adjust( i ); // check for adjustment\n                }\n            }\n            return true;\n        } else { \n            return false; \n        }\n    }\n    \n    \n    \n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /**\n        @notice increment reward rate for collector\n     */\n    function adjust( uint _index ) internal {\n        Adjust memory adjustment = adjustments[ _index ];\n        if ( adjustment.rate != 0 ) {\n            if ( adjustment.add ) { // if rate should increase\n                info[ _index ].rate = info[ _index ].rate.add( adjustment.rate ); // raise rate\n                if ( info[ _index ].rate >= adjustment.target ) { // if target met\n                    adjustments[ _index ].rate = 0; // turn off adjustment\n                }\n            } else { // if rate should decrease\n                info[ _index ].rate = info[ _index ].rate.sub( adjustment.rate ); // lower rate\n                if ( info[ _index ].rate <= adjustment.target ) { // if target met\n                    adjustments[ _index ].rate = 0; // turn off adjustment\n                }\n            }\n        }\n    }\n    \n    \n    \n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt( uint _rate ) public view returns ( uint ) {\n        return IERC20( OHM ).totalSupply().mul( _rate ).div( 1000000 );\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint\n     */\n    function nextRewardFor( address _recipient ) public view returns ( uint ) {\n        uint reward;\n        for ( uint i = 0; i < info.length; i++ ) {\n            if ( info[ i ].recipient == _recipient ) {\n                reward = nextRewardAt( info[ i ].rate );\n            }\n        }\n        return reward;\n    }\n    \n    \n    \n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n        @notice adds recipient for distributions\n        @param _recipient address\n        @param _rewardRate uint\n     */\n    function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {\n        require( _recipient != address(0) );\n        info.push( Info({\n            recipient: _recipient,\n            rate: _rewardRate\n        }));\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n        @param _recipient address\n     */\n    function removeRecipient( uint _index, address _recipient ) external onlyPolicy() {\n        require( _recipient == info[ _index ].recipient );\n        info[ _index ].recipient = address(0);\n        info[ _index ].rate = 0;\n    }\n\n    /**\n        @notice set adjustment info for a collector's reward rate\n        @param _index uint\n        @param _add bool\n        @param _rate uint\n        @param _target uint\n     */\n    function setAdjustment( uint _index, bool _add, uint _rate, uint _target ) external onlyPolicy() {\n        adjustments[ _index ] = Adjust({\n            add: _add,\n            rate: _rate,\n            target: _target\n        });\n    }\n}"
    },
    "contracts/libraries/Policy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../interfaces/IPolicy.sol\";\n\ncontract Policy is IPolicy {\n  address internal _policy;\n  address internal _newPolicy;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _policy = msg.sender;\n    emit OwnershipTransferred(address(0), _policy);\n  }\n\n  function policy() public view override returns (address) {\n    return _policy;\n  }\n\n  modifier onlyPolicy() {\n    require(_policy == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renouncePolicy() public virtual override onlyPolicy {\n    emit OwnershipTransferred(_policy, address(0));\n    _policy = address(0);\n  }\n\n  function pushPolicy(address newPolicy_) public virtual override onlyPolicy {\n    require(newPolicy_ != address(0), \"Ownable: new owner is the zero address\");\n    _newPolicy = newPolicy_;\n  }\n\n  function pullPolicy() public virtual override {\n    require(msg.sender == _newPolicy);\n    emit OwnershipTransferred(_policy, _newPolicy);\n    _policy = _newPolicy;\n  }\n}\n"
    },
    "contracts/interfaces/IPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IPolicy {\n\n    function policy() external view returns (address);\n\n    function renouncePolicy() external;\n  \n    function pushPolicy( address newPolicy_ ) external;\n\n    function pullPolicy() external;\n}\n"
    },
    "contracts/rewarders/ComplexRewarderTime.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"../interfaces/IRewarder.sol\";\nimport \"../interfaces/IMiniChefV2.sol\";\nimport \"../libraries/Ownable.sol\";\nimport \"../libraries/SafeERC20.sol\";\n\ncontract ComplexRewarderTime is IRewarder, Ownable {\n  using SafeERC20 for IERC20;\n\n  IERC20 private rewardToken;\n\n  /// @notice Info of each MCV2 user.\n  /// `amount` LP token amount the user has provided.\n  /// `rewardDebt` The amount of reward entitled to the user.\n  struct UserInfo {\n    uint256 amount;\n    uint256 rewardDebt;\n  }\n\n  /// @notice Info of each MCV2 pool.\n  /// `allocPoint` The amount of allocation points assigned to the pool.\n  /// Also known as the amount of SUSHI to distribute per block.\n  struct PoolInfo {\n    uint256 accRewardPerShare;\n    uint256 lastRewardTime;\n    uint256 allocPoint;\n  }\n\n  /// @notice Info of each pool.\n  mapping(uint256 => PoolInfo) public poolInfo;\n\n  uint256[] public poolIds;\n\n  /// @notice Info of each user that stakes LP tokens.\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n  /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\n  uint256 totalAllocPoint;\n\n  uint256 public rewardPerSecond;\n  uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n\n  address private REQUIEM_CHEF;\n\n  event LogOnReward(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount,\n    address indexed to\n  );\n  event LogPoolAddition(uint256 indexed pid, uint256 allocPoint);\n  event LogSetPool(uint256 indexed pid, uint256 allocPoint);\n  event LogUpdatePool(\n    uint256 indexed pid,\n    uint256 lastRewardTime,\n    uint256 lpSupply,\n    uint256 accRewardPerShare\n  );\n  event LogRewardPerSecond(uint256 rewardPerSecond);\n  event LogInit();\n\n  constructor(\n    IERC20 _rewardToken,\n    uint256 _rewardPerSecond,\n    address _REQUIEM_CHEF\n  ) {\n    rewardToken = _rewardToken;\n    rewardPerSecond = _rewardPerSecond;\n    REQUIEM_CHEF = _REQUIEM_CHEF;\n  }\n\n  function onReward(\n    uint256 pid,\n    address _user,\n    address to,\n    uint256,\n    uint256 lpToken\n  ) external override onlyMCV2 {\n    PoolInfo memory pool = updatePool(pid);\n    UserInfo storage user = userInfo[pid][_user];\n    uint256 pending;\n    if (user.amount > 0) {\n      pending =\n        (user.amount * pool.accRewardPerShare) /\n        ACC_TOKEN_PRECISION -\n        user.rewardDebt;\n      rewardToken.safeTransfer(to, pending);\n    }\n    user.amount = lpToken;\n    user.rewardDebt = (lpToken * pool.accRewardPerShare) / ACC_TOKEN_PRECISION;\n    emit LogOnReward(_user, pid, pending, to);\n  }\n\n  function pendingTokens(\n    uint256 pid,\n    address user,\n    uint256\n  )\n    external\n    view\n    override\n    returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts)\n  {\n    IERC20[] memory _rewardTokens = new IERC20[](1);\n    _rewardTokens[0] = (rewardToken);\n    uint256[] memory _rewardAmounts = new uint256[](1);\n    _rewardAmounts[0] = pendingToken(pid, user);\n    return (_rewardTokens, _rewardAmounts);\n  }\n\n  /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n  /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n  function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n    rewardPerSecond = _rewardPerSecond;\n    emit LogRewardPerSecond(_rewardPerSecond);\n  }\n\n  modifier onlyMCV2() {\n    require(msg.sender == REQUIEM_CHEF, \"Only MCV2 can call this function.\");\n    _;\n  }\n\n  /// @notice Returns the number of MCV2 pools.\n  function poolLength() public view returns (uint256 pools) {\n    pools = poolIds.length;\n  }\n\n  /// @notice Add a new LP to the pool. Can only be called by the owner.\n  /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n  /// @param allocPoint AP of the new pool.\n  /// @param _pid Pid on MCV2\n  function add(uint256 allocPoint, uint256 _pid) public onlyOwner {\n    require(poolInfo[_pid].lastRewardTime == 0, \"Pool already exists\");\n    uint256 lastRewardTime = block.timestamp;\n    totalAllocPoint += allocPoint;\n\n    poolInfo[_pid] = PoolInfo({\n      allocPoint: allocPoint,\n      lastRewardTime: lastRewardTime,\n      accRewardPerShare: 0\n    });\n    poolIds.push(_pid);\n    emit LogPoolAddition(_pid, allocPoint);\n  }\n\n  /// @notice Update the given pool's reward allocation point and `IRewarder` contract. Can only be called by the owner.\n  /// @param _pid The index of the pool. See `poolInfo`.\n  /// @param _allocPoint New AP of the pool.\n  function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {\n    totalAllocPoint = totalAllocPoint - poolInfo[_pid].allocPoint + _allocPoint;\n    poolInfo[_pid].allocPoint = _allocPoint;\n    emit LogSetPool(_pid, _allocPoint);\n  }\n\n  /// @notice View function to see pending Token\n  /// @param _pid The index of the pool. See `poolInfo`.\n  /// @param _user Address of user.\n  /// @return pending reward for a given user.\n  function pendingToken(uint256 _pid, address _user)\n    public\n    view\n    returns (uint256 pending)\n  {\n    PoolInfo memory pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_user];\n    uint256 accRewardPerShare = pool.accRewardPerShare;\n    uint256 lpSupply = IMiniChefV2(REQUIEM_CHEF).lpToken(_pid).balanceOf(\n      REQUIEM_CHEF\n    );\n    if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n      uint256 time = block.timestamp - pool.lastRewardTime;\n      uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) /\n        totalAllocPoint;\n      accRewardPerShare += (rewardAmount * ACC_TOKEN_PRECISION) / lpSupply;\n    }\n    pending =\n      (user.amount * accRewardPerShare) /\n      ACC_TOKEN_PRECISION -\n      user.rewardDebt;\n  }\n\n  /// @notice Update reward variables for all pools. Be careful of gas spending!\n  /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\n  function massUpdatePools(uint256[] calldata pids) external {\n    uint256 len = pids.length;\n    for (uint256 i = 0; i < len; ++i) {\n      updatePool(pids[i]);\n    }\n  }\n\n  /// @notice Update reward variables of the given pool.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @return pool Returns the pool that was updated.\n  function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n    pool = poolInfo[pid];\n    if (block.timestamp > pool.lastRewardTime) {\n      uint256 lpSupply = IMiniChefV2(REQUIEM_CHEF).lpToken(pid).balanceOf(\n        REQUIEM_CHEF\n      );\n\n      if (lpSupply > 0) {\n        uint256 time = block.timestamp - pool.lastRewardTime;\n        uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) /\n          totalAllocPoint;\n        pool.accRewardPerShare =\n          pool.accRewardPerShare +\n          (rewardAmount * ACC_TOKEN_PRECISION) /\n          lpSupply;\n      }\n      pool.lastRewardTime = block.timestamp;\n      poolInfo[pid] = pool;\n      emit LogUpdatePool(\n        pid,\n        pool.lastRewardTime,\n        lpSupply,\n        pool.accRewardPerShare\n      );\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IRewarder {\n  function onReward(\n    uint256 pid,\n    address user,\n    address recipient,\n    uint256 rewardAmount,\n    uint256 newLpAmount\n  ) external;\n\n  function pendingTokens(\n    uint256 pid,\n    address user,\n    uint256 rewardAmount\n  ) external view returns (IERC20[] memory, uint256[] memory);\n}\n"
    },
    "contracts/interfaces/IMiniChefV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\nimport \"./ERC20/IERC20.sol\";\n\ninterface IMiniChefV2 {\n  function lpToken(uint256 _pid) external view returns (IERC20);\n}\n"
    },
    "contracts/RequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/Initializable.sol\";\nimport \"./libraries/ERC20Burnable.sol\";\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./libraries/Ownable.sol\";\n\n/**\n *  Governance token for requiem.finance\n *  - Flexible minting allowed for flexibility\n *  - Total supply cap for better control\n *  - Controllable minters with indivitual caps\n */\ncontract RequiemERC20Token is ERC20Permit, Ownable, ERC20Burnable {\n  uint256 public MAX_TOTAL_SUPPLY = 10_000_000_000 ether; // 10bn\n\n  mapping(address => uint256) public minters; // minter's address => minter's max cap\n  mapping(address => uint256) public minters_minted;\n\n  /* ========== EVENTS ========== */\n  event MinterUpdate(address indexed account, uint256 cap);\n  event MaxTotalSupplyUpdated(uint256 _newCap);\n\n  /* ========== Modifiers =============== */\n\n  modifier onlyMinter() {\n    require(minters[msg.sender] > 0, \"Only minter can interact\");\n    _;\n  }\n\n  constructor() ERC20(\"Requiem Token\", \"REQT\", 18) ERC20Permit(\"REQT\") {}\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function mint(address _recipient, uint256 _amount) public onlyMinter {\n    minters_minted[_msgSender()] += _amount;\n    require(\n      minters[_msgSender()] >= minters_minted[_msgSender()],\n      \"Minting amount exceeds minter cap\"\n    );\n    _mint(_recipient, _amount);\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal override {\n    super._beforeTokenTransfer(_from, _to, _amount);\n    if (_from == address(0)) {\n      // When minting tokens\n      require(\n        totalSupply() + _amount <= MAX_TOTAL_SUPPLY,\n        \"Max total supply exceeded\"\n      );\n    }\n    if (_to == address(0)) {\n      // When burning tokens\n      require(\n        MAX_TOTAL_SUPPLY >= _amount,\n        \"Burn amount exceeds max total supply\"\n      );\n      MAX_TOTAL_SUPPLY -= _amount;\n    }\n  }\n\n  /* ========== OWNER FUNCTIONS ========== */\n\n  function setMinter(address _account, uint256 _minterCap) external onlyOwner {\n    require(_account != address(0), \"invalid address\");\n    require(\n      minters_minted[_account] <= _minterCap,\n      \"Minter already minted a larger amount than new cap\"\n    );\n    minters[_account] = _minterCap;\n    emit MinterUpdate(_account, _minterCap);\n  }\n\n  function resetMaxTotalSupply(uint256 _newCap) external onlyOwner {\n    require(_newCap >= totalSupply(), \"_newCap is below current total supply\");\n    MAX_TOTAL_SUPPLY = _newCap;\n    emit MaxTotalSupplyUpdated(_newCap);\n  }\n}\n"
    },
    "contracts/libraries/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ERC20.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for ``accounts``'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) public virtual {\n    uint256 currentAllowance = allowance(account, _msgSender());\n    require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n    unchecked {\n      _approve(account, _msgSender(), currentAllowance - amount);\n    }\n    _burn(account, amount);\n  }\n}\n"
    },
    "contracts/RedRequiem.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./libraries/ERC20Burnable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./interfaces/IGovernanceToken.sol\";\n\ncontract RedRequiem is ERC20Burnable, IGovernanceToken, Ownable {\n    using SafeERC20 for IERC20;\n\n    // flags\n    uint256 private _unlocked;\n\n    uint256 public constant MINDAYS = 7;\n    uint256 public constant MAXDAYS = 3 * 365;\n\n    uint256 public constant MAXTIME = MAXDAYS * 1 days; // 3 years\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 50000; // 50%\n    uint256 public constant PRECISION = 100000; // 5 decimals\n\n    address public lockedToken;\n    address public penaltyCollector;\n    uint256 public minLockedAmount;\n    uint256 public earlyWithdrawPenaltyRate;\n\n    struct LockedBalance {\n        uint256 amount;\n        uint256 end;\n    }\n\n    mapping(address => LockedBalance) public locked;\n    mapping(address => uint256) public mintedForLock;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier lock() {\n        require(_unlocked == 1, \"LOCKED\");\n        _unlocked = 0;\n        _;\n        _unlocked = 1;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lockedToken,\n        uint256 _minLockedAmount) ERC20(_name, _symbol, 18)\n    {\n        lockedToken = _lockedToken;\n        minLockedAmount = _minLockedAmount;\n        earlyWithdrawPenaltyRate = 30000; // 30%\n        _unlocked = 1;\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function locked__of(address _addr) external view override returns (uint256) {\n        return locked[_addr].amount;\n    }\n\n    function locked__end(address _addr) external view override returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    function voting_power_unlock_time(uint256 _value, uint256 _unlock_time) public view override returns (uint256) {\n        uint256 _now = block.timestamp;\n        if (_unlock_time <= _now) return 0;\n        uint256 _lockedSeconds = _unlock_time - _now;\n        if (_lockedSeconds >= MAXTIME) {\n            return _value;\n        }\n        return _value * _lockedSeconds / MAXTIME;\n    }\n\n    function voting_power_locked_days(uint256 _value, uint256 _days) public pure override returns (uint256) {\n        if (_days >= MAXDAYS) {\n            return _value;\n        }\n        return _value * _days / MAXDAYS;\n    }\n\n    function deposit_for(address _addr, uint256 _value) external override {\n        require(_value >= minLockedAmount, \"less than min amount\");\n        _deposit_for(_addr, _value, 0);\n    }\n\n    function create_lock(uint256 _value, uint256 _days) external override {\n        require(_value >= minLockedAmount, \"less than min amount\");\n        require(locked[_msgSender()].amount == 0, \"Withdraw old tokens first\");\n        require(_days >= MINDAYS, \"Voting lock can be 7 days min\");\n        require(_days <= MAXDAYS, \"Voting lock can be 4 years max\");\n        _deposit_for(_msgSender(), _value, _days);\n    }\n\n    function increase_amount(uint256 _value) external override {\n        require(_value >= minLockedAmount, \"less than min amount\");\n        _deposit_for(_msgSender(), _value, 0);\n    }\n\n    function increase_unlock_time(uint256 _days) external override {\n        require(_days >= MINDAYS, \"Voting lock can be 7 days min\");\n        require(_days <= MAXDAYS, \"Voting lock can be 4 years max\");\n        _deposit_for(_msgSender(), 0, _days);\n    }\n\n    function withdraw() external override lock {\n        LockedBalance storage _locked = locked[_msgSender()];\n        uint256 _now = block.timestamp;\n        require(_locked.amount > 0, \"Nothing to withdraw\");\n        require(_now >= _locked.end, \"The lock didn't expire\");\n        uint256 _amount = _locked.amount;\n        _locked.end = 0;\n        _locked.amount = 0;\n        _burn(_msgSender(), mintedForLock[_msgSender()]);\n        mintedForLock[_msgSender()] = 0;\n        IERC20(lockedToken).safeTransfer(_msgSender(), _amount);\n\n        emit Withdraw(_msgSender(), _amount, _now);\n    }\n\n    // This will charge PENALTY if lock is not expired yet\n    function emergencyWithdraw() external lock {\n        LockedBalance storage _locked = locked[_msgSender()];\n        uint256 _now = block.timestamp;\n        require(_locked.amount > 0, \"Nothing to withdraw\");\n        uint256 _amount = _locked.amount;\n        if (_now < _locked.end) {\n            uint256 _fee = _amount * earlyWithdrawPenaltyRate / PRECISION;\n            _penalize(_fee);\n            _amount = _amount - _fee;\n        }\n        _locked.end = 0;\n        _locked.amount = 0;\n        _burn(_msgSender(), mintedForLock[_msgSender()]);\n        mintedForLock[_msgSender()] = 0;\n\n        IERC20(lockedToken).safeTransfer(_msgSender(), _amount);\n\n        emit Withdraw(_msgSender(), _amount, _now);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _deposit_for(\n        address _addr,\n        uint256 _value,\n        uint256 _days\n    ) internal lock {\n        LockedBalance storage _locked = locked[_addr];\n        uint256 _now = block.timestamp;\n        uint256 _amount = _locked.amount;\n        uint256 _end = _locked.end;\n        uint256 _vp;\n        if (_amount == 0) {\n            _vp = voting_power_locked_days(_value, _days);\n            _locked.amount = _value;\n            _locked.end = _now + _days * 1 days;\n        } else if (_days == 0) {\n            _vp = voting_power_unlock_time(_value, _end);\n            _locked.amount = _amount + _value;\n        } else {\n            require(_value == 0, \"Cannot increase amount and extend lock in the same time\");\n            _vp = voting_power_locked_days(_amount, _days);\n            _locked.end = _end + _days * 1 days;\n            require(_locked.end - _now <= MAXTIME, \"Cannot extend lock to more than 4 years\");\n        }\n        require(_vp > 0, \"No benefit to lock\");\n        if (_value > 0) {\n            IERC20(lockedToken).safeTransferFrom(_msgSender(), address(this), _value);\n        }\n        _mint(_addr, _vp);\n        mintedForLock[_addr] += _vp;\n\n        emit Deposit(_addr, _locked.amount, _locked.end, _now);\n    }\n\n    function _penalize(uint256 _amount) internal {\n        if (penaltyCollector != address(0)) {\n            // send to collector if `penaltyCollector` set\n            IERC20(lockedToken).safeTransfer(penaltyCollector, _amount);\n        } else {\n            ERC20Burnable(lockedToken).burn(_amount);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setMinLockedAmount(uint256 _minLockedAmount) external onlyOwner {\n        minLockedAmount = _minLockedAmount;\n        emit MinLockedAmountSet(_minLockedAmount);\n    }\n\n    function setEarlyWithdrawPenaltyRate(uint256 _earlyWithdrawPenaltyRate) external onlyOwner {\n        require(_earlyWithdrawPenaltyRate <= MAX_WITHDRAWAL_PENALTY, \"withdrawal penalty is too high\"); // <= 50%\n        earlyWithdrawPenaltyRate = _earlyWithdrawPenaltyRate;\n        emit EarlyWithdrawPenaltySet(_earlyWithdrawPenaltyRate);\n    }\n\n    function setPenaltyCollector(address _addr) external onlyOwner {\n        penaltyCollector = _addr;\n        emit PenaltyCollectorSet(_addr);\n    }\n\n    /* =============== EVENTS ==================== */\n    event Deposit(address indexed provider, uint256 value, uint256 locktime, uint256 timestamp);\n    event Withdraw(address indexed provider, uint256 value, uint256 timestamp);\n    event PenaltyCollectorSet(address indexed addr);\n    event EarlyWithdrawPenaltySet(uint256 indexed penalty);\n    event MinLockedAmountSet(uint256 indexed amount);\n}\n"
    },
    "contracts/interfaces/IGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\ninterface IGovernanceToken {\n    function locked__of(address _addr) external view returns (uint256);\n\n    function locked__end(address _addr) external view returns (uint256);\n\n    function voting_power_unlock_time(uint256 _value, uint256 _unlock_time) external view returns (uint256);\n\n    function voting_power_locked_days(uint256 _value, uint256 _days) external view returns (uint256);\n\n    function deposit_for(address _addr, uint256 _value) external;\n\n    function create_lock(uint256 _value, uint256 _days) external;\n\n    function increase_amount(uint256 _value) external;\n\n    function increase_unlock_time(uint256 _days) external;\n\n    function withdraw() external;\n}\n"
    },
    "contracts/RequiemChef.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"./libraries/Ownable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRewarder.sol\";\nimport \"./interfaces/IFundDistributor.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n/*  RequiemChef is a fork from Sushi's MiniChef v2 with slightly modification.\n    1.  Rewards will be transferred from a seperated contract so that it will be more flexible to switch between:\n        [mint reward token directly] OR [transfer them instead]\n    2.  Add a Harvest all function to quickly harvest rewards from all the deposited pools\n*/\ncontract RequiemChef is Ownable {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    uint256 amount;\n    int256 rewardDebt;\n  }\n\n  struct PoolInfo {\n    uint256 accRewardPerShare;\n    uint256 lastRewardTime;\n    uint256 allocPoint;\n  }\n\n  IERC20 public reward;\n  IFundDistributor public fund;\n\n  /// @notice Info of each MCV2 pool.\n  PoolInfo[] public poolInfo;\n  /// @notice Address of the LP token for each MCV2 pool.\n  IERC20[] public lpToken;\n  /// @notice Address of each `IRewarder` contract in MCV2.\n  IRewarder[] public rewarder;\n\n  /// @notice Info of each user that stakes LP tokens.\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n  /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\n  uint256 public totalAllocPoint = 0;\n\n  uint256 public rewardPerSecond;\n  uint256 private constant ACC_REWARD_PRECISION = 1e12;\n\n  constructor(IERC20 _reward, IFundDistributor _fund) {\n    reward = _reward;\n    fund = _fund;\n  }\n\n  /* ========== PUBLIC FUNCTIONS ========== */\n\n  /// @notice Returns the number of MCV2 pools.\n  function poolLength() public view returns (uint256 pools) {\n    pools = poolInfo.length;\n  }\n\n  /// @notice View function to see pending reward on frontend.\n  /// @param _pid The index of the pool. See `poolInfo`.\n  /// @param _user Address of user.\n  /// @return pending reward for a given user.\n  function pendingReward(uint256 _pid, address _user)\n    external\n    view\n    returns (uint256 pending)\n  {\n    PoolInfo memory pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_user];\n    uint256 accRewardPerShare = pool.accRewardPerShare;\n    uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\n    if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n      uint256 time = block.timestamp - pool.lastRewardTime;\n      uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) /\n        totalAllocPoint;\n      accRewardPerShare += (rewardAmount * ACC_REWARD_PRECISION) / lpSupply;\n    }\n    pending = uint256(\n      int256((user.amount * accRewardPerShare) / ACC_REWARD_PRECISION) -\n        user.rewardDebt\n    );\n  }\n\n  /// @notice Update reward variables of the given pool.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @return pool Returns the pool that was updated.\n  function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n    pool = poolInfo[pid];\n    if (block.timestamp > pool.lastRewardTime) {\n      uint256 lpSupply = lpToken[pid].balanceOf(address(this));\n      if (lpSupply > 0) {\n        uint256 time = block.timestamp - pool.lastRewardTime;\n        uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) /\n          totalAllocPoint;\n        pool.accRewardPerShare +=\n          (rewardAmount * ACC_REWARD_PRECISION) /\n          lpSupply;\n      }\n      pool.lastRewardTime = block.timestamp;\n      poolInfo[pid] = pool;\n      emit LogUpdatePool(\n        pid,\n        pool.lastRewardTime,\n        lpSupply,\n        pool.accRewardPerShare\n      );\n    }\n  }\n\n  /// @notice Update reward variables for all pools. Be careful of gas spending!\n  /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\n  function massUpdatePools(uint256[] calldata pids) external {\n    uint256 len = pids.length;\n    for (uint256 i = 0; i < len; ++i) {\n      updatePool(pids[i]);\n    }\n  }\n\n  /// @notice Deposit LP tokens to MCV2 for reward allocation.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @param amount LP token amount to deposit.\n  /// @param to The receiver of `amount` deposit benefit.\n  function deposit(\n    uint256 pid,\n    uint256 amount,\n    address to\n  ) public {\n    PoolInfo memory pool = updatePool(pid);\n    UserInfo storage user = userInfo[pid][to];\n\n    // Effects\n    user.amount += amount;\n    user.rewardDebt += int256(\n      (amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION\n    );\n\n    // Interactions\n    IRewarder _rewarder = rewarder[pid];\n    if (address(_rewarder) != address(0)) {\n      _rewarder.onReward(pid, to, to, 0, user.amount);\n    }\n\n    lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\n\n    emit Deposit(msg.sender, pid, amount, to);\n  }\n\n  /// @notice Withdraw LP tokens from MCV2.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @param amount LP token amount to withdraw.\n  /// @param to Receiver of the LP tokens.\n  function withdraw(\n    uint256 pid,\n    uint256 amount,\n    address to\n  ) public {\n    PoolInfo memory pool = updatePool(pid);\n    UserInfo storage user = userInfo[pid][msg.sender];\n\n    // Effects\n    user.rewardDebt -= int256(\n      (amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION\n    );\n    user.amount -= amount;\n    // Interactions\n    IRewarder _rewarder = rewarder[pid];\n    if (address(_rewarder) != address(0)) {\n      _rewarder.onReward(pid, msg.sender, to, 0, user.amount);\n    }\n\n    lpToken[pid].safeTransfer(to, amount);\n\n    emit Withdraw(msg.sender, pid, amount, to);\n  }\n\n  /// @notice Harvest proceeds for transaction sender to `to`.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @param to Receiver of rewards.\n  function harvest(uint256 pid, address to) public {\n    PoolInfo memory pool = updatePool(pid);\n    UserInfo storage user = userInfo[pid][msg.sender];\n    int256 accumulatedReward = int256(\n      (user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION\n    );\n    uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\n\n    // Effects\n    user.rewardDebt = accumulatedReward;\n\n    // Interactions\n    fund.distributeTo(to, _pendingReward);\n\n    IRewarder _rewarder = rewarder[pid];\n    if (address(_rewarder) != address(0)) {\n      _rewarder.onReward(pid, msg.sender, to, _pendingReward, user.amount);\n    }\n\n    emit Harvest(msg.sender, pid, _pendingReward);\n  }\n\n  /// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @param amount LP token amount to withdraw.\n  /// @param to Receiver of the LP tokens and rewards.\n  function withdrawAndHarvest(\n    uint256 pid,\n    uint256 amount,\n    address to\n  ) public {\n    PoolInfo memory pool = updatePool(pid);\n    UserInfo storage user = userInfo[pid][msg.sender];\n    int256 accumulatedReward = int256(\n      (user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION\n    );\n    uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\n\n    // Effects\n    user.rewardDebt =\n      accumulatedReward -\n      int256((amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\n    user.amount -= amount;\n\n    // Interactions\n    fund.distributeTo(to, _pendingReward);\n\n    IRewarder _rewarder = rewarder[pid];\n    if (address(_rewarder) != address(0)) {\n      _rewarder.onReward(pid, msg.sender, to, _pendingReward, user.amount);\n    }\n\n    lpToken[pid].safeTransfer(to, amount);\n\n    emit Withdraw(msg.sender, pid, amount, to);\n    emit Harvest(msg.sender, pid, _pendingReward);\n  }\n\n  /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @param to Receiver of the LP tokens.\n  function emergencyWithdraw(uint256 pid, address to) public {\n    UserInfo storage user = userInfo[pid][msg.sender];\n    uint256 amount = user.amount;\n    user.amount = 0;\n    user.rewardDebt = 0;\n\n    IRewarder _rewarder = rewarder[pid];\n    if (address(_rewarder) != address(0)) {\n      _rewarder.onReward(pid, msg.sender, to, 0, 0);\n    }\n\n    // Note: transfer can fail or succeed if `amount` is zero.\n    lpToken[pid].safeTransfer(to, amount);\n    emit EmergencyWithdraw(msg.sender, pid, amount, to);\n  }\n\n  function harvestAllRewards(address to) external {\n    uint256 length = poolInfo.length;\n    for (uint256 pid = 0; pid < length; ++pid) {\n      if (userInfo[pid][msg.sender].amount > 0) {\n        harvest(pid, to);\n      }\n    }\n  }\n\n  /* ========== INTERNAL FUNCTIONS ========== */\n\n  function checkPoolDuplicate(IERC20 _lpToken) internal view {\n    uint256 length = poolInfo.length;\n    for (uint256 pid = 0; pid < length; ++pid) {\n      require(lpToken[pid] != _lpToken, \"add: existing pool?\");\n    }\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /// @notice Add a new LP to the pool. Can only be called by the owner.\n  /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n  /// @param allocPoint AP of the new pool.\n  /// @param _lpToken Address of the LP ERC-20 token.\n  /// @param _rewarder Address of the rewarder delegate.\n  function add(\n    uint256 allocPoint,\n    IERC20 _lpToken,\n    IRewarder _rewarder\n  ) public onlyOwner {\n    checkPoolDuplicate(_lpToken);\n\n    totalAllocPoint += allocPoint;\n    lpToken.push(_lpToken);\n    rewarder.push(_rewarder);\n\n    poolInfo.push(\n      PoolInfo({\n        allocPoint: allocPoint,\n        lastRewardTime: block.timestamp,\n        accRewardPerShare: 0\n      })\n    );\n    emit LogPoolAddition(lpToken.length - 1, allocPoint, _lpToken, _rewarder);\n  }\n\n  /// @notice Update the given pool's reward allocation point and `IRewarder` contract. Can only be called by the owner.\n  /// @param _pid The index of the pool. See `poolInfo`.\n  /// @param _allocPoint New AP of the pool.\n  /// @param _rewarder Address of the rewarder delegate.\n  /// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.\n  function set(\n    uint256 _pid,\n    uint256 _allocPoint,\n    IRewarder _rewarder,\n    bool overwrite\n  ) public onlyOwner {\n    totalAllocPoint = totalAllocPoint - poolInfo[_pid].allocPoint + _allocPoint;\n    poolInfo[_pid].allocPoint = _allocPoint;\n    if (overwrite) {\n      rewarder[_pid] = _rewarder;\n    }\n    emit LogSetPool(\n      _pid,\n      _allocPoint,\n      overwrite ? _rewarder : rewarder[_pid],\n      overwrite\n    );\n  }\n\n  /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n  /// @param _rewardPerSecond The amount of reward to be distributed per second.\n  function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n    rewardPerSecond = _rewardPerSecond;\n    emit LogRewardPerSecond(_rewardPerSecond);\n  }\n\n  /// @notice Set the new fund contract.\n  /// @param _fund The address of new fund contract.\n  function setFund(IFundDistributor _fund) public onlyOwner {\n    fund = _fund;\n    emit PoolFundChanged(address(_fund));\n  }\n\n  /* =============== EVENTS ==================== */\n\n  event Deposit(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount,\n    address indexed to\n  );\n  event Withdraw(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount,\n    address indexed to\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount,\n    address indexed to\n  );\n  event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\n  event LogPoolAddition(\n    uint256 indexed pid,\n    uint256 allocPoint,\n    IERC20 indexed lpToken,\n    IRewarder indexed rewarder\n  );\n  event LogSetPool(\n    uint256 indexed pid,\n    uint256 allocPoint,\n    IRewarder indexed rewarder,\n    bool overwrite\n  );\n  event LogUpdatePool(\n    uint256 indexed pid,\n    uint256 lastRewardTime,\n    uint256 lpSupply,\n    uint256 accRewardPerShare\n  );\n  event LogRewardPerSecond(uint256 rewardPerSecond);\n  event PoolFundChanged(address indexed fund);\n}\n"
    },
    "contracts/interfaces/IFundDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IFundDistributor {\n  function distributeTo(address _receiver, uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/VaultOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./Ownable.sol\";\n\ncontract VaultOwned is Ownable {\n    \n  address internal _vault;\n\n  function setVault( address vault_ ) external onlyOwner() returns ( bool ) {\n    _vault = vault_;\n\n    return true;\n  }\n\n  function vault() public view returns (address) {\n    return _vault;\n  }\n\n  modifier onlyVault() {\n    require( _vault == msg.sender, \"VaultOwned: caller is not the Vault\" );\n    _;\n  }\n\n}"
    },
    "contracts/RequiemTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/ERC20/IERC20Mintable.sol\";\nimport \"./interfaces/IREQTERC20.sol\";\nimport \"./interfaces/IBondingCalculator.sol\";\n\ncontract RequiemTreasury is Manageable, ITreasury {\n  using SafeERC20 for IERC20;\n\n  event Deposit(address indexed token, uint256 amount, uint256 value);\n  event Withdrawal(address indexed token, uint256 amount, uint256 value);\n  event CreateDebt(\n    address indexed debtor,\n    address indexed token,\n    uint256 amount,\n    uint256 value\n  );\n  event RepayDebt(\n    address indexed debtor,\n    address indexed token,\n    uint256 amount,\n    uint256 value\n  );\n  event ReservesManaged(address indexed token, uint256 amount);\n  event ReservesUpdated(uint256 indexed totalReserves);\n  event ReservesAudited(uint256 indexed totalReserves);\n  event RewardsMinted(\n    address indexed caller,\n    address indexed recipient,\n    uint256 amount\n  );\n  event ChangeQueued(MANAGING indexed managing, address queued);\n  event ChangeActivated(\n    MANAGING indexed managing,\n    address activated,\n    bool result\n  );\n\n  enum MANAGING {\n    RESERVEDEPOSITOR,\n    RESERVESPENDER,\n    RESERVETOKEN,\n    RESERVEMANAGER,\n    LIQUIDITYDEPOSITOR,\n    LIQUIDITYTOKEN,\n    LIQUIDITYMANAGER,\n    DEBTOR,\n    REWARDMANAGER,\n    SREQT\n  }\n\n  address public immutable REQT;\n  uint256 public immutable blocksNeededForQueue;\n\n  address[] public reserveTokens; // Push only, beware false-positives.\n  mapping(address => bool) public isReserveToken;\n  mapping(address => uint256) public reserveTokenQueue; // Delays changes to mapping.\n\n  address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isReserveDepositor;\n  mapping(address => uint256) public reserveDepositorQueue; // Delays changes to mapping.\n\n  address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isReserveSpender;\n  mapping(address => uint256) public reserveSpenderQueue; // Delays changes to mapping.\n\n  address[] public liquidityTokens; // Push only, beware false-positives.\n  mapping(address => bool) public isLiquidityToken;\n  mapping(address => uint256) public LiquidityTokenQueue; // Delays changes to mapping.\n\n  address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isLiquidityDepositor;\n  mapping(address => uint256) public LiquidityDepositorQueue; // Delays changes to mapping.\n\n  mapping(address => address) public bondCalculator; // bond calculator for liquidity token\n\n  address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isReserveManager;\n  mapping(address => uint256) public ReserveManagerQueue; // Delays changes to mapping.\n\n  address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isLiquidityManager;\n  mapping(address => uint256) public LiquidityManagerQueue; // Delays changes to mapping.\n\n  address[] public debtors; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isDebtor;\n  mapping(address => uint256) public debtorQueue; // Delays changes to mapping.\n  mapping(address => uint256) public debtorBalance;\n\n  address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\n  mapping(address => bool) public isRewardManager;\n  mapping(address => uint256) public rewardManagerQueue; // Delays changes to mapping.\n\n  address public sREQT;\n  uint256 public sREQTQueue; // Delays change to sREQT address\n\n  uint256 public totalReserves; // Risk-free value of all assets\n  uint256 public totalDebt;\n\n  constructor(\n    address _REQT,\n    address _DAI,\n    address _TUSD,\n    address _REQTDAI,\n    uint256 _blocksNeededForQueue\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n\n    isReserveToken[_DAI] = true;\n    reserveTokens.push(_DAI);\n\n    isReserveToken[_TUSD] = true;\n    reserveTokens.push(_TUSD);\n\n    isLiquidityToken[_REQTDAI] = true;\n    liquidityTokens.push(_REQTDAI);\n\n    blocksNeededForQueue = _blocksNeededForQueue;\n  }\n\n  /**\n        @notice allow approved address to deposit an asset for REQT\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (uint256 send_) {\n    require(isReserveToken[_token] || isLiquidityToken[_token], \"Not accepted\");\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n    if (isReserveToken[_token]) {\n      require(isReserveDepositor[msg.sender], \"Not approved\");\n    } else {\n      require(isLiquidityDepositor[msg.sender], \"Not approved\");\n    }\n\n    uint256 value = valueOf(_token, _amount);\n    // mint REQT needed and store amount of rewards for distribution\n    send_ = value - _profit;\n    IERC20Mintable(REQT).mint(msg.sender, send_);\n\n    totalReserves += value;\n    emit ReservesUpdated(totalReserves);\n\n    emit Deposit(_token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to burn REQT for reserves\n        @param _amount uint\n        @param _token address\n     */\n  function withdraw(uint256 _amount, address _token) external {\n    require(isReserveToken[_token], \"Not accepted\"); // Only reserves can be used for redemptions\n    require(isReserveSpender[msg.sender] == true, \"Not approved\");\n\n    uint256 value = valueOf(_token, _amount);\n    IREQTERC20(REQT).burnFrom(msg.sender, value);\n\n    totalReserves -= value;\n    emit ReservesUpdated(totalReserves);\n\n    IERC20(_token).safeTransfer(msg.sender, _amount);\n\n    emit Withdrawal(_token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n  function incurDebt(uint256 _amount, address _token) external {\n    require(isDebtor[msg.sender], \"Not approved\");\n    require(isReserveToken[_token], \"Not accepted\");\n\n    uint256 value = valueOf(_token, _amount);\n\n    uint256 maximumDebt = IERC20(sREQT).balanceOf(msg.sender); // Can only borrow against sREQT held\n    uint256 availableDebt = maximumDebt - debtorBalance[msg.sender];\n    require(value <= availableDebt, \"Exceeds debt limit\");\n\n    debtorBalance[msg.sender] += value;\n    totalDebt += value;\n\n    totalReserves -= value;\n    emit ReservesUpdated(totalReserves);\n\n    IERC20(_token).transfer(msg.sender, _amount);\n\n    emit CreateDebt(msg.sender, _token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n  function repayDebtWithReserve(uint256 _amount, address _token) external {\n    require(isDebtor[msg.sender], \"Not approved\");\n    require(isReserveToken[_token], \"Not accepted\");\n\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 value = valueOf(_token, _amount);\n    debtorBalance[msg.sender] -= value;\n    totalDebt -= value;\n\n    totalReserves += value;\n    emit ReservesUpdated(totalReserves);\n\n    emit RepayDebt(msg.sender, _token, _amount, value);\n  }\n\n  /**\n        @notice allow approved address to repay borrowed reserves with REQT\n        @param _amount uint\n     */\n  function repayDebtWithREQT(uint256 _amount) external {\n    require(isDebtor[msg.sender], \"Not approved\");\n\n    IREQTERC20(REQT).burnFrom(msg.sender, _amount);\n\n    debtorBalance[msg.sender] -= _amount;\n    totalDebt -= _amount;\n\n    emit RepayDebt(msg.sender, REQT, _amount, _amount);\n  }\n\n  /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n  function manage(address _token, uint256 _amount) external {\n    if (isLiquidityToken[_token]) {\n      require(isLiquidityManager[msg.sender], \"Not approved\");\n    } else {\n      require(isReserveManager[msg.sender], \"Not approved\");\n    }\n\n    uint256 value = valueOf(_token, _amount);\n    require(value <= excessReserves(), \"Insufficient reserves\");\n\n    totalReserves -= value;\n    emit ReservesUpdated(totalReserves);\n\n    IERC20(_token).safeTransfer(msg.sender, _amount);\n\n    emit ReservesManaged(_token, _amount);\n  }\n\n  /**\n        @notice send epoch reward to staking contract\n     */\n  function mintRewards(address _recipient, uint256 _amount) external {\n    require(isRewardManager[msg.sender], \"Not approved\");\n    require(_amount <= excessReserves(), \"Insufficient reserves\");\n\n    IERC20Mintable(REQT).mint(_recipient, _amount);\n\n    emit RewardsMinted(msg.sender, _recipient, _amount);\n  }\n\n  /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n  function excessReserves() public view returns (uint256) {\n    return totalReserves - (IERC20(REQT).totalSupply() - totalDebt);\n  }\n\n  /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n  function auditReserves() external onlyManager {\n    uint256 reserves;\n    for (uint256 i = 0; i < reserveTokens.length; i++) {\n      reserves += valueOf(\n        reserveTokens[i],\n        IERC20(reserveTokens[i]).balanceOf(address(this))\n      );\n    }\n    for (uint256 i = 0; i < liquidityTokens.length; i++) {\n      reserves += valueOf(\n        liquidityTokens[i],\n        IERC20(liquidityTokens[i]).balanceOf(address(this))\n      );\n    }\n    totalReserves = reserves;\n    emit ReservesUpdated(reserves);\n    emit ReservesAudited(reserves);\n  }\n\n  /**\n        @notice returns REQT valuation of asset\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n  function valueOf(address _token, uint256 _amount)\n    public\n    view\n    override\n    returns (uint256 value_)\n  {\n    if (isReserveToken[_token]) {\n      // convert amount to match REQT decimals\n      value_ =\n        _amount *\n        (10**(IERC20(REQT).decimals() - IERC20(_token).decimals()));\n    }  else if (isLiquidityToken[_token]) {\n      value_ = IBondingCalculator(bondCalculator[_token]).valuation(\n        _token,\n        _amount\n      );\n    }\n  }\n  \n  /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n  function queue(MANAGING _managing, address _address)\n    external\n    onlyManager\n    returns (bool)\n  {\n    require(_address != address(0));\n    if (_managing == MANAGING.RESERVEDEPOSITOR) {\n      // 0\n      reserveDepositorQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.RESERVESPENDER) {\n      // 1\n      reserveSpenderQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.RESERVETOKEN) {\n      // 2\n      reserveTokenQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.RESERVEMANAGER) {\n      // 3\n      ReserveManagerQueue[_address] = block.number + blocksNeededForQueue * 2;\n    } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n      // 4\n      LiquidityDepositorQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n      // 5\n      LiquidityTokenQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n      // 6\n      LiquidityManagerQueue[_address] = block.number + blocksNeededForQueue * 2;\n    } else if (_managing == MANAGING.DEBTOR) {\n      // 7\n      debtorQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.REWARDMANAGER) {\n      // 8\n      rewardManagerQueue[_address] = block.number + blocksNeededForQueue;\n    } else if (_managing == MANAGING.SREQT) {\n      // 9\n      sREQTQueue = block.number + blocksNeededForQueue;\n    } else return false;\n\n    emit ChangeQueued(_managing, _address);\n    return true;\n  }\n\n  /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @param _calculator address\n        @return bool\n     */\n  function toggle(\n    MANAGING _managing,\n    address _address,\n    address _calculator\n  ) external onlyManager returns (bool) {\n    require(_address != address(0));\n    bool result;\n    if (_managing == MANAGING.RESERVEDEPOSITOR) {\n      // 0\n      if (requirements(reserveDepositorQueue, isReserveDepositor, _address)) {\n        reserveDepositorQueue[_address] = 0;\n        if (!listContains(reserveDepositors, _address)) {\n          reserveDepositors.push(_address);\n        }\n      }\n      result = !isReserveDepositor[_address];\n      isReserveDepositor[_address] = result;\n    } else if (_managing == MANAGING.RESERVESPENDER) {\n      // 1\n      if (requirements(reserveSpenderQueue, isReserveSpender, _address)) {\n        reserveSpenderQueue[_address] = 0;\n        if (!listContains(reserveSpenders, _address)) {\n          reserveSpenders.push(_address);\n        }\n      }\n      result = !isReserveSpender[_address];\n      isReserveSpender[_address] = result;\n    } else if (_managing == MANAGING.RESERVETOKEN) {\n      // 2\n      if (requirements(reserveTokenQueue, isReserveToken, _address)) {\n        reserveTokenQueue[_address] = 0;\n        if (!listContains(reserveTokens, _address)) {\n          reserveTokens.push(_address);\n        }\n      }\n      result = !isReserveToken[_address];\n      isReserveToken[_address] = result;\n    } else if (_managing == MANAGING.RESERVEMANAGER) {\n      // 3\n      if (requirements(ReserveManagerQueue, isReserveManager, _address)) {\n        reserveManagers.push(_address);\n        ReserveManagerQueue[_address] = 0;\n        if (!listContains(reserveManagers, _address)) {\n          reserveManagers.push(_address);\n        }\n      }\n      result = !isReserveManager[_address];\n      isReserveManager[_address] = result;\n    } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n      // 4\n      if (\n        requirements(LiquidityDepositorQueue, isLiquidityDepositor, _address)\n      ) {\n        liquidityDepositors.push(_address);\n        LiquidityDepositorQueue[_address] = 0;\n        if (!listContains(liquidityDepositors, _address)) {\n          liquidityDepositors.push(_address);\n        }\n      }\n      result = !isLiquidityDepositor[_address];\n      isLiquidityDepositor[_address] = result;\n    } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n      // 5\n      if (requirements(LiquidityTokenQueue, isLiquidityToken, _address)) {\n        LiquidityTokenQueue[_address] = 0;\n        if (!listContains(liquidityTokens, _address)) {\n          liquidityTokens.push(_address);\n        }\n      }\n      result = !isLiquidityToken[_address];\n      isLiquidityToken[_address] = result;\n      bondCalculator[_address] = _calculator;\n    } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n      // 6\n      if (requirements(LiquidityManagerQueue, isLiquidityManager, _address)) {\n        LiquidityManagerQueue[_address] = 0;\n        if (!listContains(liquidityManagers, _address)) {\n          liquidityManagers.push(_address);\n        }\n      }\n      result = !isLiquidityManager[_address];\n      isLiquidityManager[_address] = result;\n    } else if (_managing == MANAGING.DEBTOR) {\n      // 7\n      if (requirements(debtorQueue, isDebtor, _address)) {\n        debtorQueue[_address] = 0;\n        if (!listContains(debtors, _address)) {\n          debtors.push(_address);\n        }\n      }\n      result = !isDebtor[_address];\n      isDebtor[_address] = result;\n    } else if (_managing == MANAGING.REWARDMANAGER) {\n      // 8\n      if (requirements(rewardManagerQueue, isRewardManager, _address)) {\n        rewardManagerQueue[_address] = 0;\n        if (!listContains(rewardManagers, _address)) {\n          rewardManagers.push(_address);\n        }\n      }\n      result = !isRewardManager[_address];\n      isRewardManager[_address] = result;\n    } else if (_managing == MANAGING.SREQT) {\n      // 9\n      sREQTQueue = 0;\n      sREQT = _address;\n      result = true;\n    } else return false;\n\n    emit ChangeActivated(_managing, _address, result);\n    return true;\n  }\n\n  /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n  function requirements(\n    mapping(address => uint256) storage queue_,\n    mapping(address => bool) storage status_,\n    address _address\n  ) internal view returns (bool) {\n    if (!status_[_address]) {\n      require(queue_[_address] != 0, \"Must queue\");\n      require(queue_[_address] <= block.number, \"Queue not expired\");\n      return true;\n    }\n    return false;\n  }\n\n  /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n  function listContains(address[] storage _list, address _token)\n    internal\n    view\n    returns (bool)\n  {\n    for (uint256 i = 0; i < _list.length; i++) {\n      if (_list[i] == _token) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IERC20Mintable {\n  function mint(uint256 amount_) external;\n\n  function mint(address account_, uint256 ammount_) external;\n}\n"
    },
    "contracts/interfaces/IREQTERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IREQTERC20 {\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/IBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IBondingCalculator {\n  function valuation(address pair_, uint256 amount_)\n    external\n    view\n    returns (uint256 _value);\n}\n"
    },
    "contracts/RequiemUV2BondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IUniswapV2TypePair.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SqrtMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemUV2BondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SqrtMath for uint256;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  function getKValue(address _pair) public view returns (uint256 k_) {\n    uint256 token0 = IERC20(IUniswapV2TypePair(_pair).token0()).decimals();\n    uint256 token1 = IERC20(IUniswapV2TypePair(_pair).token1()).decimals();\n    uint256 decimals = token0 + token1 - IERC20(_pair).decimals();\n\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2TypePair(_pair)\n      .getReserves();\n    k_ = (reserve0 * reserve1) / (10**decimals);\n  }\n\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    _value = getKValue(_pair).sqrrt() * 2;\n  }\n\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IUniswapV2TypePair(_pair).totalSupply();\n\n    _value = totalValue\n       * FixedPoint.fraction(amount_, totalSupply).decode112with18()\n      /1e18;\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2TypePair(_pair)\n      .getReserves();\n\n    uint256 reserve;\n    if (IUniswapV2TypePair(_pair).token0() == REQT) {\n      reserve = reserve1;\n    } else {\n      reserve = reserve0;\n    }\n    return\n      reserve * (2 * (10**IERC20(REQT).decimals())) / getTotalValue(_pair);\n  }\n}\n"
    },
    "contracts/interfaces/IUniswapV2TypePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IUniswapV2TypePair {\n  function totalSupply() external view returns (uint256);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n}\n"
    },
    "contracts/libraries/math/SqrtMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary SqrtMath {\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = a / 2 + 1;\n      while (b < c) {\n        c = b;\n        b = ((a / b) + b) / 2;\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n"
    },
    "contracts/RequiemQBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemWeightedPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SqrtMath.sol\";\nimport \"./libraries/math/FullMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemQBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  /**\n  * note for general pairs the price does not necessarily satisfy the conditon\n  * that the lp value consists 50% of the one and the other token since the mid\n  * price is the quotient of the reserves. That is not necessarily the case for\n  * general pairs, therefore, we have to calculate the price separately and apply it\n  * to the reserve amount for conversion\n  * - calculates the total liquidity value denominated in the provided token\n  * - uses the 1bps ouytput reserves for that calculation to avoid slippage to\n  *   have a too large impact\n  * - the sencond token input argument is ignored when using pools with only 2 tokens\n  * @param _pair general pair that has the RequiemSwap interface implemented\n  *  - the value is calculated as the geometric average of input and output\n  *  - is consistent with the uniswapV2-type case \n */\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair).getReserves();\n    (address otherToken, uint256 reservesOther) = REQT ==\n      IRequiemWeightedPair(_pair).token0()\n      ? (IRequiemWeightedPair(_pair).token1(), reserve1)\n      : (IRequiemWeightedPair(_pair).token0(), reserve0);\n\n    uint256 decimals = IERC20(otherToken).decimals() +\n      IERC20(REQT).decimals() -\n      IERC20(_pair).decimals() -\n      4;\n\n    uint256 syntReserveREQT = IRequiemSwap(_pair).calculateSwapGivenIn(\n      otherToken,\n      address(0),\n      reservesOther / 10000\n    );\n\n    _value =\n      SqrtMath.sqrrt((syntReserveREQT * reservesOther) / (10**decimals)) *\n      2;\n  }\n\n    /**\n  * - calculates the value in reqt of the input LP amount provided\n  * @param _pair general pair that has the RequiemSwap interface implemented\n  * @param amount_ the amount of LP to price in REQT\n  *  - is consistent with the uniswapV2-type case \n */\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemWeightedPair(_pair).totalSupply();\n\n    _value = FullMath.mulDivRoundingUp(totalValue, amount_, totalSupply);\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair).getReserves();\n\n    uint256 reserve;\n    if (IRequiemWeightedPair(_pair).token0() == REQT) {\n      reserve = reserve1;\n    } else {\n      reserve = reserve0;\n    }\n    return\n      (reserve * (2 * (10**IERC20(REQT).decimals()))) / (getTotalValue(_pair));\n  }\n}\n"
    },
    "contracts/interfaces/IRequiemWeightedPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./IRequiemPairERC20.sol\";\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemWeightedPair is IRequiemPairERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IRequiemSwap {\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRequiemPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPairERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/mocks/MockBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../libraries/math/FullMath.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\n\ninterface IOwnable {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n\n  function pushManagement(address newOwner_) external;\n\n  function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n  address internal _owner;\n  address internal _newOwner;\n\n  event OwnershipPushed(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event OwnershipPulled(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _owner = msg.sender;\n    emit OwnershipPushed(address(0), _owner);\n  }\n\n  function policy() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyPolicy() {\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceManagement() public virtual override onlyPolicy {\n    emit OwnershipPushed(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function pushManagement(address newOwner_)\n    public\n    virtual\n    override\n    onlyPolicy\n  {\n    require(newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipPushed(_owner, newOwner_);\n    _newOwner = newOwner_;\n  }\n\n  function pullManagement() public virtual override {\n    require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n    emit OwnershipPulled(_owner, _newOwner);\n    _owner = _newOwner;\n  }\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = add(div(a, 2), 1);\n      while (b < c) {\n        c = b;\n        b = div(add(div(a, b), b), 2);\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function toBytes32(address a) internal pure returns (bytes32 b) {\n    assembly {\n      let m := mload(0x40)\n      a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n      mstore(0x40, add(m, 52))\n      b := m\n    }\n  }\n\n  function addressToString(address _address)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes32 _bytes = toBytes32(_address);\n    bytes memory HEX = \"0123456789abcdef\";\n    bytes memory _addr = new bytes(42);\n\n    _addr[0] = \"0\";\n    _addr[1] = \"x\";\n\n    for (uint256 i = 0; i < 20; i++) {\n      _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n      _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n    }\n\n    return string(_addr);\n  }\n}\n\ninterface IERC20 {\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  // TODO comment actual hash value.\n  bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n    keccak256(\"ERC20Token\");\n\n  mapping(address => uint256) internal _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 internal _totalSupply;\n\n  string internal _name;\n\n  string internal _symbol;\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      _allowances[sender][msg.sender].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account_, uint256 ammount_) internal virtual {\n    require(account_ != address(0), \"ERC20: mint to the zero address\");\n    _beforeTokenTransfer(address(this), account_, ammount_);\n    _totalSupply = _totalSupply.add(ammount_);\n    _balances[account_] = _balances[account_].add(ammount_);\n    emit Transfer(address(this), account_, ammount_);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _beforeTokenTransfer(\n    address from_,\n    address to_,\n    uint256 amount_\n  ) internal virtual {}\n}\n\ninterface IERC2612Permit {\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function nonces(address owner) external view returns (uint256);\n}\n\nlibrary Counters {\n  using SafeMath for uint256;\n\n  struct Counter {\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    counter._value += 1;\n  }\n\n  function decrement(Counter storage counter) internal {\n    counter._value = counter._value.sub(1);\n  }\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n  using Counters for Counters.Counter;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant PERMIT_TYPEHASH =\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor() {\n    uint256 chainID;\n    assembly {\n      chainID := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(name())),\n        keccak256(bytes(\"1\")), // Version\n        chainID,\n        address(this)\n      )\n    );\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n    bytes32 hashStruct = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        amount,\n        _nonces[owner].current(),\n        deadline\n      )\n    );\n\n    bytes32 _hash = keccak256(\n      abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n    );\n\n    address signer = ecrecover(_hash, v, r, s);\n    require(\n      signer != address(0) && signer == owner,\n      \"ZeroSwapPermit: Invalid signature\"\n    );\n\n    _nonces[owner].increment();\n    _approve(owner, spender, amount);\n  }\n\n  function nonces(address owner) public view override returns (uint256) {\n    return _nonces[owner].current();\n  }\n}\n\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(\n      value,\n      \"SafeERC20: decreased allowance below zero\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(\n      data,\n      \"SafeERC20: low-level call failed\"\n    );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n\ninterface ITreasury {\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (bool);\n\n  function valueOfToken(address _token, uint256 _amount)\n    external\n    view\n    returns (uint256 value_);\n}\n\ninterface IBondCalculator {\n  function valuation(address _LP, uint256 _amount)\n    external\n    view\n    returns (uint256);\n\n  function markdown(address _LP) external view returns (uint256);\n}\n\ninterface IStaking {\n  function stake(uint256 _amount, address _recipient) external returns (bool);\n}\n\ninterface IStakingHelper {\n  function stake(uint256 _amount, address _recipient) external;\n}\n\ncontract MockBondDepository is Ownable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n  address public immutable bondCalculator; // calculates value of LP tokens\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _bondCalculator\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    // bondCalculator should be address(0) if not LP bond\n    bondCalculator = _bondCalculator;\n    isLiquidityBond = (_bondCalculator != address(0));\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _fee uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _fee,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      fee: _fee,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.FEE) {\n      // 2\n      require(_input <= 10000, \"DAO fee cannot exceed payout\");\n      terms.fee = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOfToken(principle, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    // profits are calculated\n    uint256 fee = payout.mul(terms.fee).div(10000);\n    uint256 profit = value.sub(payout).sub(fee);\n\n    /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) REQT\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(principle).approve(address(treasury), _amount);\n    ITreasury(treasury).deposit(_amount, principle, profit);\n\n    if (fee != 0) {\n      // fee is transferred to dao\n      IERC20(REQT).safeTransfer(DAO, fee);\n    }\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e16);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n      price_ = bondPrice()\n        .mul(IBondCalculator(bondCalculator).markdown(principle))\n        .div(100);\n    } else {\n      price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice debt ratio in same terms for reserve or liquidity bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    if (isLiquidityBond) {\n      return\n        debtRatio()\n          .mul(IBondCalculator(bondCalculator).markdown(principle))\n          .div(1e9);\n    } else {\n      return debtRatio();\n    }\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/RequiemStableBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemStableBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n  using SafeMath for uint112;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.1% inputAmount for that calculation\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    uint256[] memory reserves = IRequiemStableSwap(_pair).getTokenBalances();\n    uint8 quoteIndex = 1;\n    for (uint8 i = 0; i < reserves.length; i++) {\n      if (i != quoteIndex) {\n        _value += IRequiemStableSwap(_pair).calculateSwap(\n          i,\n          quoteIndex,\n          reserves[i] / 10000\n        );\n      }\n    }\n  }\n\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemStableSwap(_pair).getLpToken().totalSupply();\n\n    _value = totalValue\n      .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n      .div(1e18);\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    // (uint256 reserve0, uint256 reserve1, ) = IRequiemPair(_pair).getReserves();\n    uint256 reserve = 1;\n    // uint256 reserve;\n    // if (IRequiemPair(_pair).token0() == REQT) {\n    //   reserve = reserve1;\n    // } else {\n    //   reserve = reserve0;\n    // }\n    return\n      reserve.mul(2 * (10**IERC20(REQT).decimals())).div(getTotalValue(_pair));\n  }\n}\n"
    },
    "contracts/interfaces/IRequiemStableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./ERC20/IERC20.sol\";\n\n// solhint-disable var-name-mixedcase\n\ninterface IRequiemStableSwap {\n\n  // pool data view functions\n  function getLpToken() external view returns (IERC20 lpToken);\n\n  function getA() external view returns (uint256);\n\n  function getAPrecise() external view returns (uint256);\n\n  function getToken(uint8 index) external view returns (IERC20);\n\n  function getTokens() external view returns (IERC20[] memory);\n\n  function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n  function getTokenBalance(uint8 index) external view returns (uint256);\n\n  function getTokenBalances() external view returns (uint256[] memory);\n\n  function getNumberOfTokens() external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n    external\n    view\n    returns (uint256);\n\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateRemoveLiquidity(address account, uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n  function calculateRemoveLiquidityOneToken(\n    address account,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount);\n\n  function getAdminBalances()\n    external\n    view\n    returns (uint256[] memory adminBalances);\n\n  function getAdminBalance(uint8 index) external view returns (uint256);\n\n  function calculateCurrentWithdrawFee(address account)\n    external\n    view\n    returns (uint256);\n\n  // state modifying functions\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    address to,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function addLiquidity(\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n}\n"
    },
    "contracts/RequiemBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IStakingHelper.sol\";\nimport \"./interfaces/IBondCalculator.sol\";\n\ncontract RequiemBondDepository is Manageable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n  address public immutable bondCalculator; // calculates value of LP tokens\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _bondCalculator\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    // bondCalculator should be address(0) if not LP bond\n    bondCalculator = _bondCalculator;\n    isLiquidityBond = (_bondCalculator != address(0));\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _fee uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _fee,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      fee: _fee,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.FEE) {\n      // 2\n      require(_input <= 10000, \"DAO fee cannot exceed payout\");\n      terms.fee = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOf(principle, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    // profits are calculated\n    uint256 fee = payout.mul(terms.fee).div(10000);\n    uint256 profit = value.sub(payout).sub(fee);\n\n    /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) REQT\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(principle).approve(address(treasury), _amount);\n    ITreasury(treasury).deposit(_amount, principle, profit);\n\n    if (fee != 0) {\n      // fee is transferred to dao\n      IERC20(REQT).safeTransfer(DAO, fee);\n    }\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e16);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n      price_ = bondPrice()\n        .mul(IBondCalculator(bondCalculator).markdown(principle))\n        .div(100);\n    } else {\n      price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice debt ratio in same terms for reserve or liquidity bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    if (isLiquidityBond) {\n      return\n        debtRatio()\n          .mul(IBondCalculator(bondCalculator).markdown(principle))\n          .div(1e9);\n    } else {\n      return debtRatio();\n    }\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/RequiemStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/Manageable.sol\";\nimport \"./interfaces/IWarmup.sol\";\nimport \"./interfaces/IDistributor.sol\";\nimport \"./interfaces/IsREQT.sol\";\n\ncontract RequiemStaking is Manageable {\n  using SafeERC20 for IERC20;\n\n  address public immutable REQT;\n  address public immutable sREQT;\n\n  struct Epoch {\n    uint256 length;\n    uint256 number;\n    uint256 endBlock;\n    uint256 distribute;\n  }\n  Epoch public epoch;\n\n  address public distributor;\n\n  address public locker;\n  uint256 public totalBonus;\n\n  address public warmupContract;\n  uint256 public warmupPeriod;\n\n  constructor(\n    address _REQT,\n    address _sREQT,\n    uint256 _epochLength,\n    uint256 _firstEpochNumber,\n    uint256 _firstEpochBlock\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_sREQT != address(0));\n    sREQT = _sREQT;\n\n    epoch = Epoch({\n      length: _epochLength,\n      number: _firstEpochNumber,\n      endBlock: _firstEpochBlock,\n      distribute: 0\n    });\n  }\n\n  struct Claim {\n    uint256 deposit;\n    uint256 gons;\n    uint256 expiry;\n    bool lock; // prevents malicious delays\n  }\n  mapping(address => Claim) public warmupInfo;\n\n  /**\n        @notice stake REQT to enter warmup\n        @param _amount uint\n        @return bool\n     */\n  function stake(uint256 _amount, address _recipient) external returns (bool) {\n    rebase();\n\n    IERC20(REQT).safeTransferFrom(msg.sender, address(this), _amount);\n\n    Claim memory info = warmupInfo[_recipient];\n    require(!info.lock, \"Deposits for account are locked\");\n\n    warmupInfo[_recipient] = Claim({\n      deposit: info.deposit + _amount,\n      gons: info.gons + IsREQT(sREQT).gonsForBalance(_amount),\n      expiry: epoch.number + warmupPeriod,\n      lock: false\n    });\n\n    IERC20(sREQT).safeTransfer(warmupContract, _amount);\n    return true;\n  }\n\n  /**\n        @notice retrieve sREQT from warmup\n        @param _recipient address\n     */\n  function claim(address _recipient) public {\n    Claim memory info = warmupInfo[_recipient];\n    if (epoch.number >= info.expiry && info.expiry != 0) {\n      delete warmupInfo[_recipient];\n      IWarmup(warmupContract).retrieve(\n        _recipient,\n        IsREQT(sREQT).balanceForGons(info.gons)\n      );\n    }\n  }\n\n  /**\n        @notice forfeit sREQT in warmup and retrieve REQT\n     */\n  function forfeit() external {\n    Claim memory info = warmupInfo[msg.sender];\n    delete warmupInfo[msg.sender];\n\n    IWarmup(warmupContract).retrieve(\n      address(this),\n      IsREQT(sREQT).balanceForGons(info.gons)\n    );\n    IERC20(REQT).safeTransfer(msg.sender, info.deposit);\n  }\n\n  /**\n        @notice prevent new deposits to address (protection from malicious activity)\n     */\n  function toggleDepositLock() external {\n    warmupInfo[msg.sender].lock = !warmupInfo[msg.sender].lock;\n  }\n\n  /**\n        @notice redeem sREQT for REQT\n        @param _amount uint\n        @param _trigger bool\n     */\n  function unstake(uint256 _amount, bool _trigger) external {\n    if (_trigger) {\n      rebase();\n    }\n    IERC20(sREQT).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(REQT).safeTransfer(msg.sender, _amount);\n  }\n\n  /**\n        @notice returns the sREQT index, which tracks rebase growth\n        @return uint\n     */\n  function index() public view returns (uint256) {\n    return IsREQT(sREQT).index();\n  }\n\n  /**\n        @notice trigger rebase if epoch over\n     */\n  function rebase() public {\n    if (epoch.endBlock <= block.number) {\n      IsREQT(sREQT).rebase(epoch.distribute, epoch.number);\n\n      epoch.endBlock += epoch.length;\n      epoch.number++;\n\n      if (distributor != address(0)) {\n        IDistributor(distributor).distribute();\n      }\n\n      uint256 balance = contractBalance();\n      uint256 staked = IsREQT(sREQT).circulatingSupply();\n\n      if (balance <= staked) {\n        epoch.distribute = 0;\n      } else {\n        epoch.distribute = balance - staked;\n      }\n    }\n  }\n\n  /**\n        @notice returns contract REQT holdings, including bonuses provided\n        @return uint\n     */\n  function contractBalance() public view returns (uint256) {\n    return IERC20(REQT).balanceOf(address(this)) + totalBonus;\n  }\n\n  /**\n        @notice provide bonus to locked staking contract\n        @param _amount uint\n     */\n  function giveLockBonus(uint256 _amount) external {\n    require(msg.sender == locker);\n    totalBonus += _amount;\n    IERC20(sREQT).safeTransfer(locker, _amount);\n  }\n\n  /**\n        @notice reclaim bonus from locked staking contract\n        @param _amount uint\n     */\n  function returnLockBonus(uint256 _amount) external {\n    require(msg.sender == locker);\n    totalBonus -= _amount;\n    IERC20(sREQT).safeTransferFrom(locker, address(this), _amount);\n  }\n\n  enum CONTRACTS {\n    DISTRIBUTOR,\n    WARMUP,\n    LOCKER\n  }\n\n  /**\n        @notice sets the contract address for LP staking\n        @param _contract address\n     */\n  function setContract(CONTRACTS _contract, address _address)\n    external\n    onlyManager\n  {\n    if (_contract == CONTRACTS.DISTRIBUTOR) {\n      // 0\n      distributor = _address;\n    } else if (_contract == CONTRACTS.WARMUP) {\n      // 1\n      require(\n        warmupContract == address(0),\n        \"Warmup cannot be set more than once\"\n      );\n      warmupContract = _address;\n    } else if (_contract == CONTRACTS.LOCKER) {\n      // 2\n      require(locker == address(0), \"Locker cannot be set more than once\");\n      locker = _address;\n    }\n  }\n\n  /**\n   * @notice set warmup period for new stakers\n   * @param _warmupPeriod uint\n   */\n  function setWarmup(uint256 _warmupPeriod) external onlyManager {\n    warmupPeriod = _warmupPeriod;\n  }\n}\n"
    },
    "contracts/interfaces/IWarmup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IWarmup {\n    function retrieve( address staker_, uint amount_ ) external;\n}"
    },
    "contracts/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IDistributor {\n    function distribute() external returns ( bool );\n}"
    },
    "contracts/interfaces/IsREQT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IsREQT {\n    function rebase( uint256 reqtProfit_, uint epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function gonsForBalance( uint amount ) external view returns ( uint );\n\n    function balanceForGons( uint gons ) external view returns ( uint );\n    \n    function index() external view returns ( uint );\n}\n"
    },
    "contracts/RedeemHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./interfaces/IBond.sol\";\n\ncontract RedeemHelper is Manageable {\n  address[] public bonds;\n\n  function redeemAll(address _recipient, bool _stake) external {\n    for (uint256 i = 0; i < bonds.length; i++) {\n      if (bonds[i] != address(0)) {\n        if (IBond(bonds[i]).pendingPayoutFor(_recipient) > 0) {\n          IBond(bonds[i]).redeem(_recipient, _stake);\n        }\n      }\n    }\n  }\n\n  function addBondContract(address _bond) external onlyPolicy {\n    require(_bond != address(0));\n    bonds.push(_bond);\n  }\n\n  function removeBondContract(uint256 _index) external onlyPolicy {\n    bonds[_index] = address(0);\n  }\n}\n"
    },
    "contracts/interfaces/IBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IBond {\n    function redeem( address _recipient, bool _stake ) external returns ( uint );\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}